---
layout: post
title:  "python代码速查"
---

Q: list

```python
# 创建和插入
selected_names = []
selected_names.append(msg["content"])

# join
"\n".join(wordBox.get("sentences"))

# 分组
from itertools import groupby
wordgroup = groupby(words, lambda v: v.get("word"))
for key,value in wordgroup:

# 转化
from builtins import map
_value = list(map(lambda v: v.get("sentence"), value))

# 过滤
wordsInput = list(filter(lambda v: len(v.strip())>0 and (v not in wordsExclusive), wordsInput))

# 计数和排序
from collections import Counter
sortedByFreq = sorted(words, key=lambda v: v['freq'])

# 只遍历数据
for line in lines:

# 同时遍历索引和数据
for idx, word in enumerate(wordArr):
```

Q: set

```python
names = set()
names.add(line.strip())
for n in names:
```

Q: 字典

```python
# 创建
dict = {"word":key,"sentences":_value}

# 创建和赋值
cookie = {}
cookie[kvs[0]] = kvs[1]

# 判断key是否存在
'a' in _map.keys()
```

Q: 网络请求

```python
# 整合了请求发送和响应解析
def list_msg(groupid):
    headers = {'User-Agent': 'Mozilla/5.0'}
    payload = {
        'groupId': groupid,
        'userId': '',
        'type': 'new',
        'count': 20
    }

    session = requests.Session()
    resp = session.post('https://yunzhijia.com/im/rest/message/listMessage', headers=headers, data=payload, cookies=cookie)
    # print(resp.content.decode('utf-8'))
    msgs = json.loads(resp.content.decode('utf-8'))["data"]["list"]
    return msgs
    
# 一个get请求的例子
resp = requests.get('https://yunzhijia.com/im/rest/group/groupList?lastUpdateTime={}&_={}'.format(timestr, timestamp), cookies=cookie)
result = json.loads(resp.content.decode('utf-8'))
msgs = result["data"]["list"]

# 另一个请求的例子
import urllib.request
req = urllib.request.Request(url, headers = headers)
res = urllib.request.urlopen(req)
html = res.read().decode('utf-8')
```

Q: 字符串

```python
# 转小写
file_name_lower = file_name.lower()

# 判断是否子串
if '测试' not in file_name_lower

# 获取子串
final_name[:final_name.rindex('.')]

# 分割
for pair in cookies.split(";"):
    kvs = pair.strip().split("=")
    cookie[kvs[0]] = kvs[1]

# 格式化
'https://yunzhijia.com/im/rest/group/groupList?lastUpdateTime={}&_={}'.format(timestr, timestamp)

# 格式化2
"(%s/%s) %s\n" % (index, wordcount, wordBox.get("word"))

# 替换
final_name = file_name.replace('[文件]:', '')

# 数字转字符串
str(len(msg)

# 是否数字
'0'.isdigit()
```

Q: 正则

```python
# 替换
insensitive_hippo = re.compile(re.escape(word), re.IGNORECASE)
sentence = insensitive_hippo.sub('balabala', sentence)

# 分割
'aaa bbb ccc'.split(' ')
rowData = rawData.split("\t")
wordsInput = re.compile(r"[\s+-/]").split(sentence)

# 找到所有匹配
word = re.compile(r'<span class="title">(.+?)</span>').findall(html)
if len(word) > 0:
    word = word[0]

# 分成三段
html = html.partition('<div id="authTrans" class="trans-wrapper trans-tab">')
if len(html) < 3:
    return results
html = html[2]

# 是否以指定子字符串开头
"xxx".startswith("#")
```

Q: json

```python
# json 转对象
import json
result = json.loads(resp.content.decode('utf-8'))
msgs = result["data"]["list"]

# 对象转json
import json
json_str = json.dumps(d, ensure_ascii=False)
```

Q: 日期时间

```python
import datetime

# 当前时间
now = datetime.datetime.now()

# 时间调整
now = now + datetime.timedelta(seconds=-100000)

# 获取秒数（int类型）
timestamp = int(now.timestamp() * 1000)

# 格式化（返回String）
timestr = now.strftime('%Y-%m-%d %H:%M:%S')

# 字符串转日期对象
in_date = '2022年2月16日'
dt1 = datetime.datetime.strptime(in_date, '%Y年%m月%d日')
# 输出: 2022-02-16 00:00:00
print(dt1)

# 日期对象加1天
dt2 = (dt1 + datetime.timedelta(days=1))
# 输出: 2022-02-17 00:00:00
print(dt2)

# 当前日期的日期对象
dt3 = datetime.datetime.now()
# 输出: 2022-02-17 14:54:00.327555
print(dt3)

# 两个日期对象差多少天
obj = dt3 - dt1
# 输出: 1
print (obj.days)

# 日期对象转字符串
out_date = dt3.strftime("%Y-%m-%d")
# 输出: 2022-02-17
print(out_date)
```

Q: 文件

```python
# 读取
with open("name.txt", "r", encoding="utf-8") as f:
    for line in f.readlines():
        if line:
            names.add(line.strip())
            
# 读取2
fileinput = open(fileNameInput, "rt")
words = fileinput.read().split("\n")

# 写入
fileOutput = open(outputName, "w", encoding='utf-8')
fileOutput.write(output)
fileOutput.close()

# 关于open()的mode参数：
'r'：读
'w'：写
'a'：追加
'r+' == r+w（可读可写，文件若不存在就报错(IOError)）
'w+' == w+r（可读可写，文件若不存在就创建）
'a+' ==a+r（可追加可写，文件若不存在就创建）
对应的，如果是二进制文件，就都加一个b就好啦：
'rb'　　'wb'　　'ab'　　'rb+'　　'wb+'　　'ab+'
```

Q: 目录

```python
from os import path

# 打开和指定文件同目录的另一个文件
fileOutput = open("%s%swordExtracted" % (path.dirname(fileInput), path.sep), "w")

# 判断文件是否存在
path.exists(mp4)

# 获取文件大小（B）
path.getsize(mp4)

# 删除目录树
import shutil
shutil.rmtree('../' + title)
```

Q: os

```python
# 执行系统命令
os.system(cmd)
os.mkdir(title)
os.chdir(title)

# 获取目录下文件名或子目录
os.listdir()
```

Q: 异常处理

```python
try:
    start()
except Exception as e:
    print('error: ', e)
```

Q: 多线程

```python
# -- 多线程处理任务，同时输出进度 --
# 需实现 objSet, finishSet, handleObj
# 可按需修改 threadCount
total = len(objSet)
objSet = objSet.difference(finishSet)
finishCount = total - len(objSet)

threadCount = 5

import threading, queue, time, progressbar
q = queue.Queue(len(objSet))
lock = threading.Lock()

objFail = set()
def worker():
	global finishCount
	while True:
		obj = q.get()
		try:
			handleObj(obj)
			lock.acquire()
			finishCount += 1
			lock.release()
		except:
			global objFail
			objFail.add(obj)
		q.task_done()


bar = progressbar.ProgressBar(max_value=total)
def showProcess():
	while finishCount < total:
		bar.update(finishCount)
		time.sleep(5)

def main():
	global objSet
	global objFail
	global threadCount
	# turn-on the worker thread
	for i in range(threadCount):
		threading.Thread(target=worker, daemon=True).start()
	# send thirty task requests to the worker
	for obj in objSet:
	    q.put(obj)
	print('All task requests sent\n', end='')


	# block until all tasks are done
	q.join()
	print('All work completed')
	if len(objFail) > 0:
		print('has fail')
		objSet = objFail
		objFail = set()
		main()

bar.update(finishCount)
threading.Thread(target=showProcess, daemon=True).start()
main()
```

Q: 暂停

```python
time.sleep(2)
```

Q: 参数

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("file", help="the full path of the file which gonna be interpreted as input")
parser.add_argument("-inorder", help="if true it will show each exam item in original order.", action="store_true")
parser.add_argument("-rate", help="indicate the rate which calculate the count of letters that will be replaced by '*' by multiplying the length of the word.", default="0.4", type=float)
parser.add_argument("-starmode", help="", action="store_true", default=True)

args = parser.parse_args()
fileInput = args.file
inorder = args.inorder
rate = args.rate
starmode = args.starmode
```

Q: 控制台输入

```python
choose = raw_input("(%s/%s) %s\n" % (index, wordcount, wordBox.get("word")))
if not choose:
    pass
```

Q: 随机数

```python
# 返回n个[0,k)之间的随机整数（不重复）
def nkrandom(begin, end, count):
    _set = set()
    while len(_set) < count:
        _set.add(random.randint(begin, end))
    return _set
    
# 洗牌
wordcount = len(words_2)
random.shuffle(words_2)
```
