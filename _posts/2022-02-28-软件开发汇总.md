---
layout: post
title:  "软件开发汇总"
---

# Java

## 进制

Q: 为啥 int 的取值范围是 $[-2^{31}, 2^{31}-1] $?

![image-20230503230217169](resources/image-20230503230217169.png)

这里注意-1~-4的补码表示规律：从“全是1”退到“全是0”。

Q: 辗转相除法将10进制转2进制的原理？

![image-20230503230032635](resources/image-20230503230032635.png)

其实不断除以2，就是将右边的bit逐个推出来。

Q: 16进制转10进制。

10转16，用辗转相除法，直到商为0：

![image-20230504123457730](resources/image-20230504123457730.png)

16转10，用权值法：

![image-20230504123543020](resources/image-20230504123543020.png)

当然，java自带了方法：

```java
System.out.println(Integer.decode("#AA")); // 170
System.out.println(Integer.parseInt("AA", 16));  // 170
System.out.println(Integer.toHexString(170)); // aa
```



## 集合

Q: 为什么推荐用ArrayDeque替代Stack?

[ref](https://juejin.cn/post/7011325257248145438)

1. stack继承于Vector，其中的多个方法都用了同步，性能差
2. 同样由于Stack的继承关系，除了栈的标准方法push和pop外，还定义了别的方法，使得栈的数据结构很容易被破坏。

Q: ArrayDeque如何实现栈？

1. push  // push
2. poll // pop
3. peek //peek

Q: ArrayDeque如何实现队列？

1. offerLast()  或 offer() // add
2. pollLast() // getAndRemove
3. peekLast()

Q: Collections工具类有哪几类方法？

1. 排序类：sort,shuffle,reverse
2. 包装类： synchronizedXxx,unmodifiableXxx,
3. 查找类：binarySearch, min, max
4. 创建类：emptyList, emptySet,  singletonXxx

对于返回null集合的方法，都推荐返回空集合，减少空指针中断的可能性。用这些方法创建空集合，可提高对象复用性，代码整洁度。

Q: Collections.synchronizedXxx方法的原理是啥？有啥缺点？如何替代？

它里面的实现方式是，用一个新的集合包装传入的原始集合，新集合的相关操作方法都用同步修饰，所以性能较差。替代方式可以使用对应的线程安全类来替代，比如ArrayList使用CopyOnWriteArrayList，HashMap使用ConcurrentHashMap，HashSet使用CopyOnWriteArraySet。

![image-20230503234026937](resources/image-20230503234026937.png)

Q: ArrayList、HashSet、HashMap对应的（推荐的）线程安全类是什么？

![image-20230503233946681](resources/image-20230503233946681.png)

## 网络

Q: 发起http请求

**创建HttpURLConnection**

```java
// 输入：url
HttpURLConnection con = null;
URL u = new URL(url);
// 判断是否走代理
ProxyAddr httpProxy = getHttpProxy();
if(httpProxy != null) {
    InetSocketAddress addr = new InetSocketAddress(httpProxy.hostname, httpProxy.port);
    Proxy proxy = new Proxy(Proxy.Type.HTTP, addr);
    con = (HttpURLConnection)u.openConnection(proxy);
} else {
    con = (HttpURLConnection)u.openConnection();
}
con.setConnectTimeout(connectTimeout);
con.setReadTimeout(socketTimeout);
return con;
```

**对HttpURLConnection根据实际情况做一些设置**

```java
con.setRequestProperty("Content-type", "application/json");
con.setRequestMethod("POST");
con.setDoOutput(true);
con.setDoInput(true);
```

**输入请求数据**

```java
connOutputStream = con.getOutputStream();
writer = new BufferedWriter(new OutputStreamWriter(connOutputStream));
writer.write(bodyJson);
writer.flush();
```

**获取响应数据**

```java
connInputStrem = con.getInputStream();
in = new InputStreamReader(connInputStrem, StandardCharsets.UTF_8);
bfreader = new BufferedReader(in);
StringBuffer sb = new StringBuffer();
String line = "";
while ((line = bfreader.readLine()) != null) {
	sb.append(line);
}
String response = sb.toString();
```

**可能抛出的异常**

1. java.net.SocketException: Unexpected end of file from server
   可能和超过了网关或代理设置的超时时间有关
1. java.net.UnknownHostException: xxx.com
   猜测和网关的dns解析异常有关
1. javax.net.ssl.SSLHandshakeException: Remote host closed connection during handshake
   ![SSLHandshakeException](resources/SSLHandshakeException.jpg)