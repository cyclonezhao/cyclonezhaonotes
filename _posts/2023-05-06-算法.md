---
layout: post
title: "算法"
mathjax: true
---

# 字符串处理

Q: KMP

输入：主字符串，模式字符串

输出：模式字符串在原字符串的位置，或-1

特点：在搜索的过程中无需回退主字符串的索引位置，遍历的时间复杂度为O(n)，n是主字符串的长度。

实现：

**第一步：求出子串的next[]**

```java
public static void main(String[] args) {
		String patternStr = "abaabcac";
		int[] nextArr = getNext(patternStr);
		for(int i : nextArr) {
			System.out.print(i + ", ");
		}
	}
```

输出：0, 0, 0, 1, 0, 2, 0, 1, 

含义：

1. 前两位的值为0；
2. 从第 i 位（i >=2, 按下标以0开始来说，后同）开始，值等于k，满足在i之前的长度为k的子串，等于从0开始，长度为k的子串；

   1. 比如，第3位的值为1，表明第2位（a）等于第0位（a）
   2. 再比如，第5位的值为2，表明第3,4位（ab）等于第0,1位（ab）

3. 如果第i位的字符，等于第next[i]位的字符，则第i位的值，等于第next[i]位的值。

   1. 这是因为在和主串比较时，当第i位的字符不等时，第next[i]位的字符肯定也不等，所以就没必要比较第next[i]
   位了，直接比较这个字符最开始出现的地方；
   2. 比如第4位是b，按理说next[4]应该等于1，但str[1] == str[4]，所以next[4] = next[1] = 0.

getNext()方法实现如下：

```java
private static int[] getNext(String patternStr) {
		int[] nextArr = new int[patternStr.length()];
		char[] patternArr = patternStr.toCharArray();
		int j = 0; 
		for(int i = 1; i < patternArr.length-1;) {
			if(patternArr[i] == patternArr[j]) {
				i++;
				j++;
				nextArr[i] = j;
				if(patternArr[i] == patternArr[j]) {
					nextArr[i] = nextArr[j];
				}
			}else if(j > 0) {
				j = nextArr[j];
			}else {
				i++;
				nextArr[i] = j;
			}
		}
		return nextArr;
	}
```

**第二步，查找首次出现的位置**

```java
public static void main(String[] args) {
		String str = "acabaabaabcacaabc";
		String patternStr = "abaabcac";
		System.out.println(search(str, patternStr));
	}
```

输出：5

分析：当子串移到主串的第2位时，发现主串的第7位，子串的第5位不相等。但next[5]==2，意味着主串的前2位（第5,6位）和子串的第0,1位是相等的，所以主串的第7位直接和子串的第2位继续比较就行，发现也不相等，所以主串的索引只好前进1位，子串的索引归0.

```text
acabaabaabcacaabc
  abaabcac
```

当子串移到主串的第5位时，发现匹配了，最后拿主串的索引减去子串的长度返回结果。

```java
private static int search(String str, String patternStr) {
		int[] nextArr = getNext(patternStr);
		for(int i : nextArr) {
			System.out.print(i + ", ");
		}
		System.out.println();
		
		char[] strArr = str.toCharArray();
		char[] patternArr = patternStr.toCharArray();
		int i = 0, j = 0;
		int result = -1;
		while(true) {
			if(strArr[i] == patternArr[j]) {
				i++;
				j++;
				if(j == patternArr.length) {
					result = i - patternArr.length;
					break;
				}
				if(i == strArr.length) {
					break;
				}
				
			}else if(j > 0){
				j = nextArr[j];
			}else {
				i++;
				if(i == strArr.length) {
					break;
				}
			}
		}
		return result;
	}
```

Q: RPN

定义两个栈：S1，S2，逐个字符遍历标准表达式：

1. 遇到左括号，压入S1
2. 遇到数字，压入S2
3. 遇到运算符：

   1. 如果该运算符优先级小于s1栈顶操作符优先级，则将栈顶运算符取出压入s2栈，循环此步骤直到不满足上述条件为止；
   2. 最后将该运算符压入s1
   
4. 遇到右括号，则将S1中的内容逐个pop出，push进S2，直到S1中遇到左括号为止（注意左括号要从S1中pop出，但不要posh进S2）

```java
public class RPN {
	private static List<String> opLst = Arrays.asList("+", "-", "*", "/");
	private static Map<String, Integer> priorityMap = new HashMap<>();
	static {
		priorityMap.put("+", 10);
		priorityMap.put("-", 10);
		priorityMap.put("*", 20);
		priorityMap.put("/", 20);
	}
	
	public static void main(String[] args) {
		String expression = "( ( 3 + 4 ) * 5 ) - 6 * 2 * ( 1 + 7 )";
		Stack<String> s1 = new Stack<>();
		Stack<String> s2 = new Stack<>();
		
		String[] expArr = expression.split(" ");
		for(String exp : expArr) {
			if("(".equals(exp)) {
				s1.push(exp);
			}else if(isInteger(exp)) {
				s2.push(exp);
			}else if(opLst.contains(exp)) {
				// 如果该运算符优先级小于s1栈顶操作符优先级，则将栈顶运算符取出压入s2栈
				// 循环此步骤直到不满足上述条件为止
				// 最后将该运算符压入s1
				while(!s1.isEmpty()) {
					String peek = s1.peek();
					if(!opLst.contains(peek)) {
						break;
					}
					if(priorityMap.get(exp) <= priorityMap.get(peek)) {
						s2.push(s1.pop());
					}else {
						break;
					}
				}
				s1.push(exp);
			}else if(")".equals(exp)) {
				while(!s1.isEmpty()) {
					String _exp = s1.pop();
					if(_exp.equals("(")) {
						break;
					}
					s2.push(_exp);
				}
			}
		}
		
		while(!s1.isEmpty()) {
			s2.push(s1.pop());
		}
		
		for(String exp: s2) {
			System.out.print(exp + ", ");
		}
	}
	
	public static boolean isInteger(String str) {    
		Pattern pattern = Pattern.compile("^-?[0-9]+(\\.[0-9]+)?$");    
		return pattern.matcher(str).matches();    
	}
}
```

输入：( ( 3 + 4 ) * 5 ) - 6 * 2 * ( 1 + 7 )

输出：3, 4, +, 5, *, 6, 2, *, 1, 7, +, *, -, 