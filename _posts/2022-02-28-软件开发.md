---
layout: post
title:  "软件开发"
---

# 软件开发

## 多线程

Q: 进程和线程的区别是啥？

**进程**拥有完整的、私有的运行时资源，特别是拥有独立的内存。

大多数的jvm都是以单进程运行。一个java应用可以通过 ProcessBuilder 对象创建其它的进程。

**线程**也被称为轻量级进程。创建一个线程比创建一个进程花费的开销要小。

线程存在于进程中 —— 每个进程至少有一个。线程共享进程的资源，包括内存和打开的文件。

从程序员的角度看，您只能从一个线程开始，称为**主线程**，这个线程能够创建其它的线程。

Q: 什么是线程中断？如何编码使得一个大任务能被中断执行？

**线程中断**就是告诉线程应该停止正在做的事情，并转而做其它事情。中断后具体做什么事情由程序员决定。

```java
public class JavaInterruptExp1 extends Thread  
{    
    public void run()  
    {    
        try  
        {   
            for (int i = 0; i < inputs.length; i++) {
                heavyCrunch(inputs[i]);
                // 主动检查是否被中断
                if (Thread.interrupted()) {
                    // 一般情况下，发现被中断，就直接抛出中断异常，以便中断处理的相关代码集中在catch块里
                    throw new InterruptedException();
                }    
            } 
        }catch(InterruptedException e){    
            // 回收必要的资源，如文件关闭等
            doSomething();
            throw e;
        }    
    }    
    public static void main(String args[])  
    {    
        JavaInterruptExp1 t1=new JavaInterruptExp1();    
        t1.start();    
        try  
        {    
            // 可由超时机制，或者用户手动点击中止按钮触发。
            t1.interrupt();    
        }catch(Exception e){System.out.println("Exception handled "+e);}    
    }    
}   
```

这套机制依托一个内部标志，称为**中断状态(interrupt status)**。

Q: 线程的sleep时间一定精确等于指定的毫秒数吗？还有哪些方法自带中断检查？

**线程的sleep时间不一定等于指定的毫秒数**。除了受限于底层操作系统提供的设施，更主要的是sleep可以被中断，sleep()方法本来就会抛出**中断异常**(InterruptedException)。

除了sleep外，还有一些方法有自带的中断检查和处理的功能：

1. object.wait()
1. thread.join()
1. java NIO. 这些方法会抛出 ClosedByInterruptException。
1. 大多数的 `java.util.concurrent`

这些方法的一个共同点是会引起阻塞。当被中断后，会自己重置**中断状态**，并抛出异常。

Q: fork-join

TODO

Q: map-reduce

TODO

## TODO

1. 性能优化
1. mq
1. jvm
1. 设计原则/模式
1. sql优化