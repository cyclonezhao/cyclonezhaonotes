---
layout: post
title:  "软件开发"
---

# 软件开发

## 多线程

Q: 进程和线程的区别是啥？

**进程**拥有完整的、私有的运行时资源，特别是拥有独立的内存。

大多数的jvm都是以单进程运行。一个java应用可以通过 ProcessBuilder 对象创建其它的进程。

**线程**也被称为轻量级进程。创建一个线程比创建一个进程花费的开销要小。

线程存在于进程中 —— 每个进程至少有一个。线程共享进程的资源，包括内存和打开的文件。

从程序员的角度看，您只能从一个线程开始，称为**主线程**，这个线程能够创建其它的线程。

Q: 什么是线程中断？如何编码使得一个大任务能被中断执行？

**线程中断**就是告诉线程应该停止正在做的事情，并转而做其它事情。中断后具体做什么事情由程序员决定。

```java
public class JavaInterruptExp1 extends Thread  
{    
    public void run()  
    {    
        try  
        {   
            for (int i = 0; i < inputs.length; i++) {
                heavyCrunch(inputs[i]);
                // 主动检查是否被中断
                if (Thread.interrupted()) {
                    // 一般情况下，发现被中断，就直接抛出中断异常，以便中断处理的相关代码集中在catch块里
                    throw new InterruptedException();
                }    
            } 
        }catch(InterruptedException e){    
            // 回收必要的资源，如文件关闭等
            doSomething();
            throw e;
        }    
    }    
    public static void main(String args[])  
    {    
        JavaInterruptExp1 t1=new JavaInterruptExp1();    
        t1.start();    
        try  
        {    
            // 可由超时机制，或者用户手动点击中止按钮触发。
            t1.interrupt();    
        }catch(Exception e){System.out.println("Exception handled "+e);}    
    }    
}   
```

这套机制依托一个内部标志，称为**中断状态(interrupt status)**。

Q: 线程的sleep时间一定精确等于指定的毫秒数吗？还有哪些方法自带中断检查？

**线程的sleep时间不一定等于指定的毫秒数**。除了受限于底层操作系统提供的设施，更主要的是sleep可以被中断，sleep()方法本来就会抛出**中断异常**(InterruptedException)。

除了sleep外，还有一些方法有自带的中断检查和处理的功能：

1. object.wait()
1. thread.join(). 如果调用 t.join()，那么当前线程会暂停执行直到t执行完成。
1. java NIO. 这些方法会抛出 ClosedByInterruptException。
1. 大多数的 `java.util.concurrent`

这些方法的一个共同点是会引起阻塞。当被中断后，会自己重置**中断状态**，并抛出异常。

Q: 线程之间如何进行通信？有可能会造成什么问题？

通过访问同一个对象。

可能会造成线程干扰和内存一致性错误。

Q: 什么是线程干扰？

**线程干扰**是指多个线程同时作用于一个共享数据，导致执行结果不符合预期的情况。

尽管是一个简单语句也有可能被翻译成多条虚拟机指令，例如`c++`，可能被分解成：

1. 读取c的当前值
1. 将取到的值加1
1. 将新值赋给c

如果c的初始值为0，有两个线程同时作用于c，一个执行c++,另一个执行c--，那么它们的“互相交错”的行为可能按以下顺序执行：

1. 线程A读取c，取到0
1. 线程B读取c，取到0
1. 线程A递增所取到的值，结果是1
1. 线程B递减所取到的值，结果是-1
1. 线程A将1赋给c
1. 线程B将-1赋给c

现在c的值是-1，线程A的更新丢失了。**此问题的重点在于结果是不可预测的，会造成程序难以检测和修复。**

Q: 什么是内存一致性错误，避免策略是什么？

**内存一致性错误**是指不同的线程对一个从原理上说是相同的数据，产生不一样视图。例如有两条语句（最后一条打印不算）：

```
int counter = 0;
counter++
print(counter)
```

如果这两条语句在一个线程里执行，我们可以明确地获得结果1。但如果在两个线程里执行，输出结果可能是0.

因此，避免策略的关键在于理解**发生前关系(happens-before relationship)**，即**保证一个语句的内存写入对另一个语句是可见的。**

在Thread.start()语句之前的所有语句的效果，对新线程里的所有语句而言**都具有发生前关系，即都是可见的**。

同样，当一个线程终止，并导致另一个线程的Thread.join()返回时，被终止的线程里的所有语句的执行效果对join()之后的语句而言都是可见的。

Q: 同步的实现原理是什么？

同步是围绕一个称为**内在锁(Intrinsic Locks)**的对象而构建的，这个对象在java的API规范里叫做**监视器(monitor)**.

任何对象都有一个与之关联的内在锁。如果要对一个对象进行独占性和一致性访问，需要先获取该对象的内在锁，访问完成后，也要释放该锁。

若一个对象的锁被一个线程持有，其他线程尝试获取相同的锁时会被阻塞。

当一个对象的内在锁被释放，会在该操作和任何后续获取相同锁之间建立发生前关系。

Q: 同步的两种用法是什么？

同步方法和同步代码块。

Q: 什么是同步方法？

**同步方法**即为用synchronized关键字修饰的方法。

如果调用实例的同步方法，那么会自动获取该实例的内在锁，方法退出（正常完成或异常退出）时会释放锁。

如果调用静态同步方法，那么会获取**类实例**的内在锁。也就是说，静态同步方法和实例同步方法是由不同的锁控制的。

```
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```

同步方法有两个效果：

1. 对于同一个对象，若一个线程调用了**其中一个同步方法**，在调用结束之前，其他线程调用该对象的**任何同步方法**都会被阻塞。
1. 同步方法调用结束后，其对后续的同步方法调用自动建立发生前关系，即内存写入效果对于后续的调用是可见的。

Q: 什么是同步代码块？

同步代码块必须指定提供内在锁的对象。

在下述例子中，lastName和nameCount必须同步更新。但nameList不是，为了提高活性，将nameList的更新放在一个单独的非同步方法里或许是个好做法。

```
public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
```

在下面的例子中，c1和c2必须同步更新，但它们的更新顺序并不重要。为了提高活性，不使用this，而使用两个不同的对象作为**监视器**.

```
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
```

最后，一个线程不能获得另一个线程拥有的锁。 但是线程可以获取它已经拥有的锁。允许一个线程多次获取同一个锁可以实现**可重入同步(Reentrant Synchronization)**。

这可以使得一个线程在一个同步代码块中，可直接或间接调用另一个（使用相同锁的）同步代码块，尽可能地减少阻塞。

Q: fork-join

TODO 

Q: map-reduce

TODO

## TODO

1. 性能优化
1. mq
1. jvm
1. 设计原则/模式
1. sql优化