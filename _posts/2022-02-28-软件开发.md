---
layout: post
title:  "软件开发"
---

# 软件开发

## 多线程

Q: 进程和线程的区别是啥？

**进程**拥有完整的、私有的运行时资源，特别是拥有独立的内存。

大多数的jvm都是以单进程运行。一个java应用可以通过 ProcessBuilder 对象创建其它的进程。

**线程**也被称为轻量级进程。创建一个线程比创建一个进程花费的开销要小。

线程存在于进程中 —— 每个进程至少有一个。线程共享进程的资源，包括内存和打开的文件。

从程序员的角度看，您只能从一个线程开始，称为**主线程**，这个线程能够创建其它的线程。

Q: 什么是线程中断？如何编码使得一个大任务能被中断执行？

**线程中断**就是告诉线程应该停止正在做的事情，并转而做其它事情。中断后具体做什么事情由程序员决定。

```java
public class JavaInterruptExp1 extends Thread  
{    
    public void run()  
    {    
        try  
        {   
            for (int i = 0; i < inputs.length; i++) {
                heavyCrunch(inputs[i]);
                // 主动检查是否被中断
                if (Thread.interrupted()) {
                    // 一般情况下，发现被中断，就直接抛出中断异常，以便中断处理的相关代码集中在catch块里
                    throw new InterruptedException();
                }    
            } 
        }catch(InterruptedException e){    
            // 回收必要的资源，如文件关闭等
            doSomething();
            throw e;
        }    
    }    
    public static void main(String args[])  
    {    
        JavaInterruptExp1 t1=new JavaInterruptExp1();    
        t1.start();    
        try  
        {    
            // 可由超时机制，或者用户手动点击中止按钮触发。
            t1.interrupt();    
        }catch(Exception e){System.out.println("Exception handled "+e);}    
    }    
}   
```

这套机制依托一个内部标志，称为**中断状态(interrupt status)**。

Q: 线程的sleep时间一定精确等于指定的毫秒数吗？还有哪些方法自带中断检查？

**线程的sleep时间不一定等于指定的毫秒数**。除了受限于底层操作系统提供的设施，更主要的是sleep可以被中断，sleep()方法本来就会抛出**中断异常**(InterruptedException)。

除了sleep外，还有一些方法有自带的中断检查和处理的功能：

1. object.wait()
1. thread.join(). 如果调用 t.join()，那么当前线程会暂停执行直到t执行完成。
1. java NIO. 这些方法会抛出 ClosedByInterruptException。
1. 大多数的 `java.util.concurrent`

这些方法的一个共同点是会引起阻塞。当被中断后，会自己重置**中断状态**，并抛出异常。

Q: 线程之间如何进行通信？有可能会造成什么问题？

通过访问同一个对象。

可能会造成线程干扰和内存一致性错误。

Q: 什么是线程干扰？

**线程干扰**是指多个线程同时作用于一个共享数据，导致执行结果不符合预期的情况。

尽管是一个简单语句也有可能被翻译成多条虚拟机指令，例如`c++`，可能被分解成：

1. 读取c的当前值
1. 将取到的值加1
1. 将新值赋给c

如果c的初始值为0，有两个线程同时作用于c，一个执行c++,另一个执行c--，那么它们的“互相交错”的行为可能按以下顺序执行：

1. 线程A读取c，取到0
1. 线程B读取c，取到0
1. 线程A递增所取到的值，结果是1
1. 线程B递减所取到的值，结果是-1
1. 线程A将1赋给c
1. 线程B将-1赋给c

现在c的值是-1，线程A的更新丢失了。**此问题的重点在于结果是不可预测的，会造成程序难以检测和修复。**

Q: 什么是内存一致性错误，避免策略是什么？

**内存一致性错误**是指不同的线程对一个从原理上说是相同的数据，产生不一样视图。例如有两条语句（最后一条打印不算）：

```
int counter = 0;
counter++
print(counter)
```

如果这两条语句在一个线程里执行，我们可以明确地获得结果1。但如果在两个线程里执行，输出结果可能是0.

因此，避免策略的关键在于理解**发生前关系(happens-before relationship)**，即**保证一个语句的内存写入对另一个语句是可见的。**

在Thread.start()语句之前的所有语句的效果，对新线程里的所有语句而言**都具有发生前关系，即都是可见的**。

同样，当一个线程终止，并导致另一个线程的Thread.join()返回时，被终止的线程里的所有语句的执行效果对join()之后的语句而言都是可见的。

Q: 同步的实现原理是什么？

同步是围绕一个称为**内在锁(Intrinsic Locks)**的对象而构建的，这个对象在java的API规范里叫做**监视器(monitor)**.

任何对象都有一个与之关联的内在锁。如果要对一个对象进行独占性和一致性访问，需要先获取该对象的内在锁，访问完成后，也要释放该锁。

若一个对象的锁被一个线程持有，其他线程尝试获取相同的锁时会被阻塞。

当一个对象的内在锁被释放，会在该操作和任何后续获取相同锁之间建立发生前关系。

Q: 同步的两种用法是什么？

同步方法和同步代码块。

Q: 什么是同步方法？

**同步方法**即为用synchronized关键字修饰的方法。

如果调用实例的同步方法，那么会自动获取该实例的内在锁，方法退出（正常完成或异常退出）时会释放锁。

如果调用静态同步方法，那么会获取**类实例**的内在锁。也就是说，静态同步方法和实例同步方法是由不同的锁控制的。

```
public class SynchronizedCounter {
    private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```

同步方法有两个效果：

1. 对于同一个对象，若一个线程调用了**其中一个同步方法**，在调用结束之前，其他线程调用该对象的**任何同步方法**都会被阻塞。
1. 同步方法调用结束后，其对后续的同步方法调用自动建立发生前关系，即内存写入效果对于后续的调用是可见的。

Q: 什么是同步代码块？

同步代码块必须指定提供内在锁的对象。

在下述例子中，lastName和nameCount必须同步更新。但nameList不是，为了提高活性，将nameList的更新放在一个单独的非同步方法里或许是个好做法。

```
public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
```

在下面的例子中，c1和c2必须同步更新，但它们的更新顺序并不重要。为了提高活性，不使用this，而使用两个不同的对象作为**监视器**.

```
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
```

最后，一个线程不能获得另一个线程拥有的锁。 但是线程可以获取它已经拥有的锁。允许一个线程多次获取同一个锁可以实现**可重入同步(Reentrant Synchronization)**。

这可以使得一个线程在一个同步代码块中，可直接或间接调用另一个（使用相同锁的）同步代码块，尽可能地减少阻塞。

Q: 什么是原子操作？volatile关键字的作用是什么？

**原子操作**要么完全发生，要么完全不发生，它不能在中间停止。

像c++这样的语句在jvm指令层面上就不是原子操作。

对于引用变量和大多数原始变量（long，double除外），读取和写入都是原子的。

对于声明为volatile的所有变量，读取和写入都是原子的。

Q: 描述一下死锁发生的原因。

**死锁**表示两个或多个线程互相等待，永远被阻塞的情况。

```
public class Deadlock {
    static class Friend {
        private final String name;
        public Friend(String name) {
            this.name = name;
        }
        public String getName() {
            return this.name;
        }
        public synchronized void bow(Friend bower) {
            System.out.format("%s: %s"
                + "  has bowed to me!%n", 
                this.name, bower.getName());
            bower.bowBack(this);
        }
        public synchronized void bowBack(Friend bower) {
            System.out.format("%s: %s"
                + " has bowed back to me!%n",
                this.name, bower.getName());
        }
    }

    public static void main(String[] args) {
        final Friend alphonse =
            new Friend("Alphonse");
        final Friend gaston =
            new Friend("Gaston");
        new Thread(new Runnable() {
            public void run() { alphonse.bow(gaston); }
        }).start();
        new Thread(new Runnable() {
            public void run() { gaston.bow(alphonse); }
        }).start();
    }
}
```

在上述例子中，事情的发生时序可能是这样的：

1. alphonse的bow()被调用，alphonse的内在锁被占用
1. gaston的bow()被调用，gaston的内在锁被占用
1. 在alphonse的bow()中，调用gaston的bowBack()，但由于bowBack的内在锁已被占用了，所以该调用被阻塞
1. 同样的，gaston的bow()方法也被阻塞

gaston的内在锁一直不会释放，alphonse的bow()方法永远等待下去，死锁。

Q: "饥饿"说的是什么？

**饥饿**描述了线程无法正常访问共享对象，因而被阻塞的情况。当共享资源被“贪婪”线程长时间不可用时，就会发生这种情况。

例如，假设一个对象提供了一个通常需要很长时间才能返回的同步方法。如果一个线程频繁调用该方法，其他也需要频繁同步访问同一对象的线程往往会被阻塞。

Q: "活锁“说的是什么？

一个线程经常响应另一个线程的动作。如果另一个线程的动作也是对另一个线程动作的响应，那么可能会导致**活锁**。

与死锁一样，**活锁线程无法取得进一步进展**。但是，线程并没有被阻塞——它们只是忙于相互响应而无法恢复工作。

这类似于两个人在走廊里迎面相遇：Alphonse 向左移动让 Gaston 通过，而 Gaston 同时向右移动让 Alphonse 通过。这样他们仍然互相阻挡，Alphonse 移动到他的右边，而 Alphonse 移动到他的左边。他们仍然互相阻挡，所以...

Q: "保护块(Guarded Blocks)"说的是什么？

线程之间经常需要协调彼此的行为，协调的一种方式是使用保护块。

考虑一个“生产者-消费者”例子：

定义一个共享数据类：Drop。具体含义见代码注释：

```
public class Drop {
    // Message sent from producer
    // to consumer.
    private String message;
    // True if consumer should wait
    // for producer to send message,
    // false if producer should wait for
    // consumer to retrieve message.
    private boolean empty = true;

    public synchronized String take() {
        // Wait until message is
        // available.
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = true;
        // Notify producer that
        // status has changed.
        notifyAll();
        return message;
    }

    public synchronized void put(String message) {
        // Wait until message has
        // been retrieved.
        while (!empty) {
            try { 
                wait();
            } catch (InterruptedException e) {}
        }
        // Toggle status.
        empty = false;
        // Store message.
        this.message = message;
        // Notify consumer that status
        // has changed.
        notifyAll();
    }
}
```

要点：

1. 调用共享对象的wait()方法调用会暂停当前线程的执行
1. 注意调用wait()之前必须持有内在锁，否则会抛出错误，一种简单的做法是在synchronized块中调用wait()
1. 一个线程调用共享对象的notifyAll()方法，会唤醒所有调用了相同对象的wait()方法的线程
1. 当线程被唤醒时，唤醒事件可能并非该线程所关心的。因此需要在循环中不断调用wait()，循环条件就是线程真正关心的条件，条件若不满足则继续循环调用wait()

接下来，定义一个生产者类和消费者类。前者往共享对象放入数据，后者从共享对象中读取数据。

*生产者类*

```
import java.util.Random;

public class Producer implements Runnable {
    private Drop drop;

    public Producer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        String importantInfo[] = {
            "Mares eat oats",
            "Does eat oats",
            "Little lambs eat ivy",
            "A kid will eat ivy too"
        };
        Random random = new Random();

        for (int i = 0;
             i < importantInfo.length;
             i++) {
            drop.put(importantInfo[i]);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
        drop.put("DONE");
    }
}
```

*消费者类*

```
import java.util.Random;

public class Consumer implements Runnable {
    private Drop drop;

    public Consumer(Drop drop) {
        this.drop = drop;
    }

    public void run() {
        Random random = new Random();
        for (String message = drop.take();
             ! message.equals("DONE");
             message = drop.take()) {
            System.out.format("MESSAGE RECEIVED: %s%n", message);
            try {
                Thread.sleep(random.nextInt(5000));
            } catch (InterruptedException e) {}
        }
    }
}
```

最后，主线程使用两个线程分别运行生产者和消费者。

```
public class ProducerConsumerExample {
    public static void main(String[] args) {
        Drop drop = new Drop();
        (new Thread(new Producer(drop))).start();
        (new Thread(new Consumer(drop))).start();
    }
}
```

简单梳理一个可能的执行时序：

1. 生产者线程启动
1. 消费者线程启动
1. 生产者线程调用Drop.put()写入数据（写入数据是缓慢的，有sleep）
1. put方法中首先检查是否有消费者正在读取(empty条件)，发现没有，则继续执行数据写入
1. 消费者线程调用Drop.take()读取数据（同样，读取过程也是缓慢的）
1. take方法中首先检查是否有生产者正在写入数据，发现果然有，因此暂缓执行（调用了wait）
1. 生产者线程写入数据完毕，唤醒所有调用了wait的线程（调用notifyAll)
1. 消费者线程被唤醒，进入下一轮循环，又首先判断是否有生产者正在写入数据，发现没有，于是继续执行读取数据
1. 在读取过程中，如果生产者又往共享对象写数据，则会由于上述原理而被阻塞，直到消费者读完数据，调用了notifyAll唤醒为止。

最后，Drop只是为了说明 Guarded Blocks 的概念而写的，为了避免重复造轮子，应该使用 java api 自带的类，例如`java.util.concurrent.BlockingQueue`.

Q: fork-join

TODO 

Q: map-reduce

TODO

## 数据库

Q: 主键、主码、主属性、关键字、候选关键字、码的区别是什么？

码：唯一标识一条记录的属性或属性组合。

![码和关键字等术语的区别](image/软件开发/码和关键字等术语的区别.png)

[图片出处](https://blog.csdn.net/qq_30113467/article/details/94181187)

Q: 三范式

xxx

Q: 数据库的约束有哪些？

xxx

Q: 什么是DDL，DML？

xxx

### 事务

Q: 多个事务并发读写共享数据可能会造成什么问题？

可能造成的问题有：

1. **脏读**
1. **不可重复读**
1. **幻读**

**======== 脏读 ========**

首先，事务A更新数据可以理解为有3个步骤：

1. 更新数据（写入了数据库，但事务没提交）
1. 提交事务
1. 或者回滚事务（撤回第1步的更新）

事务B可能在事务A更新数据的前后，以及在事务A更新数据的三个步骤之间访问数据，这样一共有4个可能的时间点：

1. 在事务A执行之前访问数据
1. 在事务A更新数据后，提交事务前访问数据
1. 在事务A更新数据后，回滚事务前访问数据
1. 在事务A执行（提交或者回滚）之后访问数据

情况1、4是正常、无问题的。

情况2：若事务A只更新了部分数据，事务B可能会读到不一致的数据

情况3：事务B会读到“原理上从未存在”的数据，称为**脏读**。

**======== 不可重复读 ========**

这个问题的含义是：同一行数据在第一次读取和第二次读取的结果不一样，看起来是不可以重复读取的。

如果事务A先读取某一行数据，然后事务B更新同一行数据，然后事务A又读取同一行数据，事务A的两次读取结果会不一样。（你在短时间内重复查询余额两次，结果是不一样的，这会不会给你造成困扰？）

**======== 幻读 ========**

这个问题和“不可重复读”有相似之处，区别在于前者特指不同的行，后者特指同一行数据。

如果事务A根据某个查询条件查出10行数据，之后事务B删除，或新增了若干匹配的数据行，然后事务A重新按照同样的查询条件执行查询，可能或获取一组不同的行。

Q: 如何解决这些并发问题？

针对这些问题，SQL标准定义了4种**事务隔离级别**：

1. **读未提交**
1. **读已提交**
1. **可重复读**
1. **可序列化**

考虑事务A执行以下任务：

```sql
BEGIN TRANSACTION;
SELECT * FROM T;
WAITFOR DELAY '00:01:00'
SELECT * FROM T;
COMMIT;
```

事务A先执行读取，然后等待1分钟，然后再做同样的读取。

**在读已提交的情况下**，事务A的第一次读取肯定是事务B已提交的结果，因此**可避免脏读**。但是事务A读完后，事务C可以更新数据，所以事务A的第二次读取到的可能是事务C所提交的结果，和第一次读取的结果不一致。也就是说，**避免不了不可重复读**的问题。

**在可重复读的情况下**，事务A的第二个select结果保证和第一个select一样，**可避免不可重复读**，在那1分钟内，并发事务B不能删除或更新已经存在的行，但可以添加新行。也就是说，**避免不了幻读**的问题。

**在可序列化的情况下**，并发事务B不能增行，也不能删改现有行，因此**可避免幻读**。

最后，其实还有一种隔离级别：**快照**。它在每一次select后都建立一份快照，下次执行同样select时直接访问快照。该级别达成的效果和可序列化是一样的，代价是额外的服务器开销。

Q: 事务的传播特性是什么？

举例：在方法A里调用方法B。

```
methodA(){
    methodB();
}
```

现在考虑方法B的事务传播特性分别设置为以下七点时所发生的情况：

1. **PROPAGATION_REQUIRED**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则方法B新建一条事务执行。
1. **PROPAGATION_SUPPORTS**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则方法B不在事务中执行。
1. **PROPAGATION_MANDATORY**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则抛异常。
1. **PROPAGATION_REQUIRES_NEW**: 方法B总是新建事务执行。若方法A已在一个事务内，则暂停方法A的事务。
1. **PROPAGATION_NOT_SUPPORTED**: 方法B始终不在事务中执行。若方法A已在一个事务内，则暂停方法A的事务。
1. **PROPAGATION_NEVER**: 方法B始终不在事务中执行。若方法A已在一个事务内，则抛出异常。
1. **PROPAGATION_NESTED**: 若方法A在一个事务内执行，方法B就建立一个嵌套事务执行，如果没有事务按着required执行，开启单独的事务。在嵌套事务开始时将建立一个保存点，如果嵌套事务失败，我们将回滚到该保存点，内部事务的回滚对外部事务没有影响。

注意 PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的区别：

1. 前者是启动一个独立的事务，它的提交和回滚是完全独立的
1. 后者是启动一个“子事务”。子事务提交了，其结果仅在事务A中可见，直到事务A提交了，其结果才能被事务A所见
1. 若事务A回滚了，所有的子事务也回滚

### 索引

Q: 为什么索引能够提升查询性能？

假设有一张表，你要查找 name='Zack' 的数据行。

如果没有索引，你只能从表头开始一行行逐个比对。在这个例子中一共查了8次。

![全表扫描](image/软件开发/全表扫描.gif)

现在定义一个索引表，其中的name列是按字母顺序排列的，index列则存储指向数据行的指针。

1. 由于name列是按字母顺序排列的，所以可按二分查找法找到符合条件的行，减少查询次数。在这个例子中一共查了3次。
1. 并且索引表一般很小，可以加载到内存里，利用内存的优势做到更快速地查询。

![索引扫描](image/软件开发/索引扫描.gif)

以上即为利用索引提升查询速度的思想（其实是**辅助索引**思想，**主索引**的提升原理需要结合物理存储的角度解释）。

[图片出处](https://dataschool.com/sql-optimization/how-indexing-works/#:~:text=Indexing%20makes%20columns%20faster%20to,row%20until%20it%20finds%20it.)

Q: 从物理存储的角度如何理解索引？

**有序文件**分成多个**块(Block)**，每个块有多条记录，每个块的第一条记录称为**块锚**。考虑数据库表在磁盘中是以如图所示的有序文件存储的（下文称数据文件）。

![有序文件](image/软件开发/有序文件.jpg)

**主索引(Primary index)**也是一个有序文件，对于数据文件中的每一个块，在索引文件中都对应一条记录。

索引文件的记录包含两个字段。字段一存储块中第一条记录的码；字段二存储块指针，指向块锚。

**从这里我们知道，主索引的排序和数据文件的块排序是一致的。**

![索引文件](image/软件开发/索引文件.jpg)

Q: 从物理角度看，索引如何提升查询性能？

设块大小B=1024B，数据表包含r=30000个记录。记录定长R=100B，且不跨块存储。那么：

1. 数据表的**块因子bfr**=floor(B/R)=10个记录/块，
1. 数据表需要的块数=ceil(r/bfr)=3000块
1. 用二分查找需要ceil(log(2,3000))=12次块访问（如果是辅助索引，只能线性扫描数据表，平均需要3000/2=1500次块访问）。

再设码长V=9B，块指针长度P=6B，那么：

1. 索引记录的长度=15B
1. 索引记录的个数=数据表需要的块数=3000个
1. 索引表的块因子=floor(B/15)=68
1. 索引表需要的块数=ceil(3000/68)=45块
1. 二分查找需要ceil(log(2,45))=6次块访问。
1. 还需要对数据表进行一次块访问，所以最终是7次块访问。

所以索引的优势就是7次块访问 vs 12次块访问。

Q: 索引一般使用什么数据结构以支持二分查找？

一般使用 B-Tree 数据结构。

在[这里](https://www.cs.usfca.edu/~galles/visualization/BTree.html)可以手动体验 B-Tree 的增、删、查的原理。

Q: 主索引和聚集索引的区别到底是啥？

1. 主索引是以主键作为索引，聚集索引不一定以主键作为索引（关键在于索引列的值可能会重复）。
1. 主索引的记录数=数据表所占用的块数；聚集索引的记录数=索引字段的去重值的个数。

在很多实现中，在建表的同时就将主键创建为聚集索引。

Q: 辅助索引和以上两者的区别又是啥？

1. 由于记录在数据库表中的物理存储方式只有一种，因此每个表只能有一个聚集索引。
1. 而辅助索引可以有多个
1. 由于辅助索引的索引字段排序和数据表记录的物理顺序不一致，所以辅助索引无法使用块锚，因此辅助索引的记录数=数据表的记录数（但是指针列是存储块锚的，因为主存和磁盘之间的数据传输以块为单位）。

Q: 创建索引有哪些好的方式？

todo

Q: 什么时候应该/不应该使用索引？

xxx

## TODO

1. 性能优化
1. mq
1. jvm
1. 设计原则/模式
1. sql优化
2. delete vs truncate
1. tcc
1. 数据库性能原理
1. 索引最左匹配原则
1. sql执行计划
1. 索引选择性、密度  selectivity density