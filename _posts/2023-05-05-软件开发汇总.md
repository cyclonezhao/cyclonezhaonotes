---
layout: post
title:  "软件开发汇总"
mathjax: true
---

# Java

## 进制

Q: 为啥 int 的取值范围是 $[-2^{31}, 2^{31}-1] $?

![image-20230503230217169](resources/image-20230503230217169.png)

这里注意-1~-4的补码表示规律：从“全是1”退到“全是0”。

Q: 辗转相除法将10进制转2进制的原理？

![image-20230503230032635](resources/image-20230503230032635.png)

其实不断除以2，就是将右边的bit逐个推出来。

Q: 16进制转10进制。

10转16，用辗转相除法，直到商为0：

![image-20230504123457730](resources/image-20230504123457730.png)

16转10，用权值法：

![image-20230504123543020](resources/image-20230504123543020.png)

当然，java自带了方法：

```java
System.out.println(Integer.decode("#AA")); // 170
System.out.println(Integer.parseInt("AA", 16));  // 170
System.out.println(Integer.toHexString(170)); // aa
```

## 集合

Q: 为什么推荐用ArrayDeque替代Stack?

[ref](https://juejin.cn/post/7011325257248145438)

1. stack继承于Vector，其中的多个方法都用了同步，性能差
2. 同样由于Stack的继承关系，除了栈的标准方法push和pop外，还定义了别的方法，使得栈的数据结构很容易被破坏。

Q: ArrayDeque如何实现栈？

1. push  // push
2. poll // pop
3. peek //peek

Q: ArrayDeque如何实现队列？

1. offerLast()  或 offer() // add
2. pollLast() // getAndRemove
3. peekLast()

Q: Collections工具类有哪几类方法？

1. 排序类：sort,shuffle,reverse
2. 包装类： synchronizedXxx,unmodifiableXxx,
3. 查找类：binarySearch, min, max
4. 创建类：emptyList, emptySet,  singletonXxx

对于返回null集合的方法，都推荐返回空集合，减少空指针中断的可能性。用这些方法创建空集合，可提高对象复用性，代码整洁度。

Q: Collections.synchronizedXxx方法的原理是啥？有啥缺点？如何替代？

它里面的实现方式是，用一个新的集合包装传入的原始集合，新集合的相关操作方法都用同步修饰，所以性能较差。替代方式可以使用对应的线程安全类来替代，比如ArrayList使用CopyOnWriteArrayList，HashMap使用ConcurrentHashMap，HashSet使用CopyOnWriteArraySet。

![image-20230503234026937](resources/image-20230503234026937.png)

Q: ArrayList、HashSet、HashMap对应的（推荐的）线程安全类是什么？

![image-20230503233946681](resources/image-20230503233946681.png)

## 多线程

[oracle的concurrency参考](https://docs.oracle.com/javase/tutorial/essential/concurrency/)

Q: Thread的创建方式

1. Thread构造器传入Runnable，然后调用start()
1. 继承Thread，实现run方法

Q: wait和notify，notifyAll

1. 注意wait有两种重载
1. wait会抛两种异常
1. notify 会抛一种异常

[ref](https://www.baeldung.com/java-wait-notify)

Q: sleep

1. 是Thread的静态方法
1. 两种重载
2. 不释放锁
1. 会被中断，抛中断异常

Q: join & isAlive

都是线程实例的方法。

1. join 等待线程结束（死亡）
1. join 会被中断，抛中断异常
1. isAlive 判断线程是否结束。

Q: yield

Thread的静态方法，给调度器一个暗示，说当前线程可以让出对处理器的使用，但调度器可以选择不理会。

Q: interrupt & interrupted

1. 将线程至于中断状态
1. 判断线程是否处于中断状态

Q: volatile

1. 变量的写入，对所有后续读取都是可见的
1. 限制指令重排序

Q: ThreadLocal

线程自身有个隐藏的threadLocalMap，一个ThreadLocal对象是这个Map的访问入口，这个对象代表这个Map的一个唯一的key，通过对象可以获得这个Map的对应value。

Q: synchronized

1. 可用于同步方法和同步代码块
1. 用于静态方法则是锁类。

Q: ReentrantLock

用法可以参考ArrayBlockingQueue的构造方法，offer，put方法等

```java
public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
```

Q: ReentrantLock如何搭配Condition？

1. ReentrantLock可以new出多个condition对象
2. Condition可替代Object的wait和notify/notifyAll方法，并且比后者更灵活，后者相当于只有一个condition对象，前者可以有选择地通知部分线程。
3. Condition对应的是await和signal/signalAll

Q: semaphore

重点方法：

1. 构造器，传入int参数
2. acquire，传入int参数
3. release

[ref](https://blog.csdn.net/sinat_36246371/article/details/53872412)

Q: Atomic

AtomicInteger

Q: Unsafe

Q: CAS

1. 比较和替换
1. 依靠CPU指令
1. 依靠java的UnSafe类
1. 存在ABA问题，使用版本号机制解决
1. 如果存在自旋锁补偿机制，在并发竞争大的场景下会造成大开销
1. 只能锁一个变量，锁不了多个变量

ABA问题体会：

账户余额有1w，小明从中取出5k，后面又有人转入5k，正常下，账户余额应该还是1w。

取钱时，由于网络故障，发起了2次请求，也就生成了2个线程。

线程1成功了，余额变5k；线程2未分配到时间片；线程3转入成功，余额变回1w。

**然后线程2判断到当前余额是1w，符合预期值，所以就将余额更新为5k。**

Q: AtomicStampedReference

1. 解决ABA的一个帮助类
2. 构造对象，输入引用值和版本号
3. 调compareAndSet，输入预期值，新值，预期版本号，新版本号。如果预期值和预期版本号都符合当前的，则更新成功。
4. 内部维护一个Pair，当前值和当前版本号。
5. 注意Pair的reference是泛型，如果是int类型，会自动装箱Integer。如果值超过[-128,127]就会在堆中创建对象，但比较方法又是用==号，。。。[ref](https://developer.aliyun.com/article/1037332#slide-4)

Q: 优先级

1. java层面有10档
1. 具体得看操作系统支持的优先级
1. 优先级高的只意味着更高概率优先执行

Q: ThreadLocal如何运用在数据库连接管理上？

这是一个线程级别单例模式的体现。

ThreadLocal 可以用于数据库连接管理上，具体实现步骤如下：

1. 创建一个 ConnectionUtils 类，用于获取数据库连接。在该类中创建一个 ThreadLocal 对象，用于存放当前线程所持有的数据库连接。

```java
public class ConnectionUtils {
    private static ThreadLocal<Connection> threadLocal = new ThreadLocal<>();

    public static Connection getConnection() {
        Connection conn = threadLocal.get();
        if (conn == null) {
            // 创建数据库连接
            conn = DriverManager.getConnection(url, username, password);
            // 将连接对象存放到 ThreadLocal 中
            threadLocal.set(conn);
        }
        return conn;
    }
}
```

2. 在数据库操作的代码中获取数据库连接时，使用 ConnectionUtils.getConnection() 方法获取连接。

```java
public void doSomeDatabaseOperation() throws SQLException {
    Connection conn = ConnectionUtils.getConnection();
    // 执行数据库操作
}
```

3. 在线程结束时，需要将 ThreadLocal 中的连接对象清除，以释放内存。

```java
public void run() {
    try {
        // 执行业务代码
    } finally {
        // 清除 ThreadLocal 中的连接对象
        ConnectionUtils.threadLocal.remove();
    }
}
```

通过这种方式，可以**避免**在多线程环境下出现连接**对象被多个线程共享**的情况，确保每个线程都拥有自己的独立连接对象，从而保证数据库操作的正确性和可靠性。

Q: ConcurrencyHashMap是如何做到线程安全的？

1. 使用volatile控制对K-V节点的修改对其他线程可见
2. 插入新的KV节点时，用synchronized锁住桶的头结点
3. 如果桶还没有头节点，则采用CAS操作保证新增头结点的线程安全性。

[ref](https://github.com/JasonGaoH/KnowledgeSummary/blob/master/Docs/Java/ConcurrentHashMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84.md)

## 线程池

Q: 为什么使用线程池？

1. 减少线程创建和销毁所带来的开销，提升响应速度
2. 线程是稀缺资源，应避免无限制的创建，使用线程池可以对线程进行统一管理、调配和监控。

Q: 线程池有哪些状态？

（初始化后默认进入）running状态，能够接受新提交的任务，也能执行阻塞队列中的任务。

（调用shutdown方法后）进入shutdown状态，不接受新提交的任务，但还能执行阻塞队列中的任务。

（调用shutdownNow方法后）进入stop状态，不接受新提交的任务，也不执行阻塞队列中的任务，会中断正在执行中的线程。

（在stop状态，自动清空队列和工作线程后）进入tidying状态。

（在tidying状态自动调用terminated()后）就进入terminated状态。

Q: 线程池有哪些重要参数，执行流程是怎样的？

参数一共有7个：核心线程数，最大线程数，空闲线程存活时间，时间描述单位，阻塞队列，线程创建工厂，拒绝策略。

执行流程大概是这样的：

1. 新的任务提交，首先检查线程池是否running状态，如果否，则调用拒绝策略拒绝任务。
2. 如果当前工作线程数小于核心线程数，则添加工作线程执行任务
3. 如果当前工作线程数大于等于核心线程数，且队列未满，则将任务放到队列里
4. 如果当前工作线程数大于等于核心线程数，且队列已满，但还没达到最大线程数，则添加工作线程执行任务
5. 如果当前工作线程数大于等于核心线程数，且队列已满，且达到了最大线程数，则调用拒绝策略拒绝任务。
6. 此外，如果线程池存在非核心线程，当空闲时间超过参数指定的空间存活时间后，则销毁线程。

[美团](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

Q: ThreadPoolExecutor的基本使用demo.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class ThreadPoolDemo {

    public static void main(String[] args) {
        // 创建一个线程池，其中最多允许同时存在 3 个线程
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 获取 ThreadPoolExecutor 对象，以便可以对其进行配置
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;

        // 输出线程池的基本信息
        System.out.println("Core pool size: " + threadPoolExecutor.getCorePoolSize());
        System.out.println("Maximum pool size: " + threadPoolExecutor.getMaximumPoolSize());
        System.out.println("Current pool size: " + threadPoolExecutor.getPoolSize());
        System.out.println("Active threads: " + threadPoolExecutor.getActiveCount());
        System.out.println("Queued tasks: " + threadPoolExecutor.getQueue().size());

        // 提交一些任务到线程池
        for (int i = 0; i < 5; i++) {
            executor.submit(new Task(i));
        }

        // 关闭线程池
        executor.shutdown();
      	// *** 也可以使用 shutdownNow()
    }

    static class Task implements Runnable {
        private int id;

        Task(int id) {
            this.id = id;
        }

        public void run() {
            System.out.println("Task " + id + " is running on thread " + Thread.currentThread().getName());
        }
    }

}
```

控制台输出：

```
Core pool size: 3
Maximum pool size: 3
Current pool size: 0
Active threads: 0
Queued tasks: 0
Task 0 is running on thread pool-1-thread-1
Task 1 is running on thread pool-1-thread-2
Task 2 is running on thread pool-1-thread-3
Task 3 is running on thread pool-1-thread-3
Task 4 is running on thread pool-1-thread-1

```

关键点：

1. ExecutorService executor = Executors.newFixedThreadPool(3);
2. ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
3. executor.submit(new Task(i));
4. executor.shutdown();

Q: ThreadPoolExecutor有多少种构造方式？

ThreadPoolExecutor有4种构造方式：

1. `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)`：指定核心线程数、最大线程数、线程空闲时间、任务队列等参数创建线程池。
2. `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)`：在第一种方式的基础上增加了一个线程工厂参数，用于创建新线程。
3. `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)`：在第一种方式的基础上增加了一个拒绝策略参数，用于当任务队列已满且线程数已达到最大线程数时，如何处理新的任务。
4. `ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)`：在第二种方式的基础上增加了一个拒绝策略参数。

Q: 线程工厂参数有哪些使用方式？

在使用 `ThreadPoolExecutor` 创建线程池时，可以指定线程工厂参数，用于创建新线程的工厂类。线程工厂参数有以下几种使用方式：

1. 使用默认的 `ThreadFactory`：不指定线程工厂参数，即使用 `Executors.defaultThreadFactory()` 方法获取默认的线程工厂类。

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
```

2. 自定义线程工厂类：实现 `ThreadFactory` 接口并重写 `newThread()` 方法，可以自定义线程工厂类来创建新线程。

```java
class MyThreadFactory implements ThreadFactory {
   private final AtomicInteger threadNumber = new AtomicInteger(1);
   private final String namePrefix;

   public MyThreadFactory(String prefix) {
       namePrefix = prefix + "-";
   }

   @Override
   public Thread newThread(Runnable r) {
       Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
       t.setDaemon(false);
       t.setPriority(Thread.NORM_PRIORITY);
       return t;
   }
}

ExecutorService executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(), new MyThreadFactory("my-thread"));
```

3. 使用线程池的静态方法设置线程工厂类：可以使用 `Executors` 类中的静态方法，如 `Executors.defaultThreadFactory()`，`Executors.privilegedThreadFactory()` 等设置线程工厂类。

```java
ExecutorService executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(), Executors.defaultThreadFactory());
```

Q: 什么是生产者-消费者模式？

在多线程开发中，如果生产者生产数据的速度很快，而消费者消费数据的速度很慢，那么生产者就必须等待消费者消费完了数据才能够继续生产数据，因为生产那么多也没有地方放啊；

同理如果消费者的速度大于生产者那么消费者就会经常处理等待状态。

所以为了达到生产者和消费者生产数据和消费数据之间的**平衡**，那么就需要一个缓冲区用来存储生产者生产的数据，所以就引入了生产者-消费者模式

[ref](https://zhuanlan.zhihu.com/p/73442055)

Q: 阻塞队列起什么作用？有哪些类型？

阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

![img](resources/725a3db5114d95675f2098c12dc331c3316963.png)

ArrayBlockingQueue VS LinkedBlockingQueue：

1. 前者预先分配一块内存，所以若初始容量大，就需要占用大内存，但数据的增删快；
2. LinkedBlockingQueue具有更高吞吐量，因为它用了两把锁分别控制读写，所以可以同时读写。

Q: 拒绝策略有哪些？

![img](resources/9ffb64cc4c64c0cb8d38dac01c89c905178456-20230421143654315-2059026.png)

也可以自己实现这个接口自定义拒绝策略：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

## NIO

NIO的三大核心部件：Channel，Buffer，Selector

数据可以从Channel中读入Buffer，也可以从Buffer中写入Channel。

Channe有read()和write()，传入Buffer作为参数，也可传入Buffer数组作为参数。

Channel有FileChannel，DatagramChannel，SocketChannel，ServerSocketChannel实现。

Buffer有allocate，flip()，clear和compact方法。

Buffer有capacity，position和limit三个重要属性。

Buffer有CharBuffer，DoubleBuffer，LongBuffer，IntBuffer等实现

两个Channel之间传输数据：transferFrom, transferTo

Q: 用java NIO 写个简单的Client/Server程序。

server端

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class MultiClientServer {

    private static final int BUFFER_SIZE = 1024;
    private static final int PORT = 8080;

    public static void main(String[] args) throws IOException {
        // 创建一个Selector
        Selector selector = Selector.open();

        // 创建一个ServerSocketChannel并注册到Selector
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(PORT));
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        System.out.println("Server started on port " + PORT);

        // 创建一个ByteBuffer来处理数据
        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);

        while (true) {
            // Selector开始轮询
            selector.select();

            // 获取SelectionKey的集合
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = selectionKeys.iterator();

            // 遍历SelectionKey集合
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();

                // 如果是ACCEPT事件，说明有新的客户端连接
                if (key.isAcceptable()) {
                    ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
                    SocketChannel clientChannel = serverChannel.accept();
                    clientChannel.configureBlocking(false);
                    clientChannel.register(selector, SelectionKey.OP_READ);
                    System.out.println("Accepted connection from " + clientChannel.getRemoteAddress());
                }

                // 如果是READ事件，说明有客户端数据可以读取
                if (key.isReadable()) {
                    SocketChannel clientChannel = (SocketChannel) key.channel();
                    buffer.clear();
                    int numRead = clientChannel.read(buffer);

                    if (numRead == -1) {
                        // 如果客户端关闭连接，关闭SocketChannel并取消SelectionKey的注册
                        key.cancel();
                        clientChannel.close();
                        System.out.println("Connection closed by client " + clientChannel.getRemoteAddress());
                    } else {
                        // 如果读取到了数据，将ByteBuffer从写模式切换到读模式，并将读取到的数据打印到控制台
                        buffer.flip();
                        byte[] data = new byte[numRead];
                        buffer.get(data);
                        System.out.println("Received from " + clientChannel.getRemoteAddress() + ": " + new String(data));
                    }
                }

                // 从SelectionKey集合中移除已经处理的SelectionKey
                keyIterator.remove();
            }
        }
    }
}
```

client端

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class NIOClient {

    public static void main(String[] args) throws IOException {

        // 创建 SocketChannel 对象
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.connect(new InetSocketAddress("localhost", 8080));

        // 创建缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        // 发送请求
        String request = "Hello, I'm NIO Client";
        buffer.put(request.getBytes("UTF-8"));
        buffer.flip();
        socketChannel.write(buffer);

        // 接收响应
        buffer.clear();
        int bytesRead = socketChannel.read(buffer);
        if (bytesRead > 0) {
            buffer.flip();
            byte[] bytes = new byte[bytesRead];
            buffer.get(bytes);
            String response = new String(bytes, "UTF-8");
            System.out.println("收到服务器响应：" + response);
        }

        socketChannel.close();
    }
}
```

## 网络

Q: 发起http请求

**创建HttpURLConnection**

```java
// 输入：url
HttpURLConnection con = null;
URL u = new URL(url);
// 判断是否走代理
ProxyAddr httpProxy = getHttpProxy();
if(httpProxy != null) {
    InetSocketAddress addr = new InetSocketAddress(httpProxy.hostname, httpProxy.port);
    Proxy proxy = new Proxy(Proxy.Type.HTTP, addr);
    con = (HttpURLConnection)u.openConnection(proxy);
} else {
    con = (HttpURLConnection)u.openConnection();
}
con.setConnectTimeout(connectTimeout);
con.setReadTimeout(socketTimeout);
return con;
```

**对HttpURLConnection根据实际情况做一些设置**

```java
con.setRequestProperty("Content-type", "application/json");
con.setRequestMethod("POST");
con.setDoOutput(true);
con.setDoInput(true);
```

**输入请求数据**

```java
connOutputStream = con.getOutputStream();
writer = new BufferedWriter(new OutputStreamWriter(connOutputStream));
writer.write(bodyJson);
writer.flush();
```

**获取响应数据**

```java
connInputStrem = con.getInputStream();
in = new InputStreamReader(connInputStrem, StandardCharsets.UTF_8);
bfreader = new BufferedReader(in);
StringBuffer sb = new StringBuffer();
String line = "";
while ((line = bfreader.readLine()) != null) {
	sb.append(line);
}
String response = sb.toString();
```

**可能抛出的异常**

1. java.net.SocketException: Unexpected end of file from server
   可能和超过了网关或代理设置的超时时间有关
1. java.net.UnknownHostException: xxx.com
   猜测和网关的dns解析异常有关
1. javax.net.ssl.SSLHandshakeException: Remote host closed connection during handshake
   ![SSLHandshakeException](resources/SSLHandshakeException.jpg)
   
# JVM

## Java内存区域和内存溢出异常

**Q: Java虚拟机所管理的内存包括那几个运行时数据区域？**

包括5个区域，分解是：方法区（包括运行时常量池）、堆、虚拟机栈、本地方法栈、程序计数器。

其中方法区和堆是由所有线程共享的数据区，其余3个是线程隔离的数据区。

此外还有直接内存，它不是虚拟机运行时数据区的一部分，但这部分内存也被频繁使用，而且也可能导致OOM。

**Q: 上述几个数据区域，展开说说。**

堆是用于存放对象实例的。

方法区用于存储虚拟机加载的类信息、静态变量等。其中的运行时常量池存放编译期生成的各种字面量和符号引用。

虚拟机栈用于存放方法调用时所产生的栈帧，栈帧包含局部变量表、操作数栈、方法出口等信息。

本地方法栈的作用和虚拟机栈类似，区别是它针对的是native方法调用。

程序计数器存放的是当前线程所执行的字节码的行号指示器，代码执行所涉及的分支、循环、跳转、异常处理等都需要依赖这个计数器来完成。

Q: 直接内存

1. 也叫堆外内存
2. 通过DirectByteBuffer对象访问
3. 在一些场景下能提升性能
   1. 因为它不需要在堆内存和直接内存之间拷贝数据。

![img](resources/7000.png)

**Q: Java虚拟机在处理对象的创建分配、内存布局和访问的过程是怎么样的？**

（jvm底层的东西，先不处理）

**Q: 有哪些原因会引发 StackOverflowError和OutOfMemoryError？**

1. 当对象数量达到最大堆的容量限制后会发生堆溢出，抛出OOM。
2. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出SOF。
3. 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OOM。
4. 方法区和运行时常量池溢出，会抛出OOM
5. 本机直接内存溢出

## 垃圾收集

**Q: 如何判定哪些对象需要回收？**

第一种是引用计数算法，java没有用这种方法，因为它不能解决对象间循环引用的问题。

Java是通过**可达性分析算法**来判断对象是否存活的。这个算法的基本思路是，以一系列称为GC Roots的对象作为起始点，从这些起始点开始向下搜索，所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连时，就认为此对象是不可用的，可回收的。

Q: 什么对象可作为GC Roots？

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中的Native方法引用的对象。

Q: Java的引用类型有哪几种？

有4种。

强引用，它在程序代码里是普遍存在的，比如Object = new Object() 这类的语句就会产生强引用。只要强引用存在，被引用的对象就不会被回收。

软引用，用于描述一些还有用，但并非必需的对象。在系统即将发生内存溢出之前，会对这些对象进行第二次回收，如果回收后还没有足够的内存，才会抛出内存溢出异常。

弱引用，也是用于描述非必需对象，但它的强度比软引用还要弱一些。在垃圾收集器工作时，无论当前内存是否足够，弱引用对象都会被回收。

虚引用，这是最弱的一种引用关系，虚引用对象随时可以被回收，也无法通过虚引用访问该对象。对一个对象设置虚引用的唯一目的就是在对象被回收时能收到一个系统通知。

Q: 被判定为不可达对象，就一定会被回收吗？

不一定。要真正宣告一个对象死亡，至少要经历两次标记过程。当对象判定不可达时，就会被第一次标记，此时对象的finalize()可能会被虚拟机调用，在finalize()内部只要和任何一个对象建立关联就可拯救自己。

但是，finalize()方法是一个妥协方法，不建议使用，建议忘掉这个方法的存在。

**Q: 什么时候会触发对象回收？**

1. 新生代Eden区满了，会触发新生代GC（Mimor GC）。
2. 经历过多次新生代GC后存活下来的对象，会升级到老年代。升级到老年代所需的内存若大于老年代的剩余内存，就会触发老年代GC（Full GC）。
3. 代码主动调用System.gc()时也会触发 Full GC。
4. 当应用程序空闲时，GC也可能会被自动调用。

**Q: 垃圾收集算法有哪些？**

**第一种是“标记-清除”算法**，它是最基础的，分为两个阶段，首先标记出需要回收的对象，标记完后统一回收被标记的对象。它的缺点有两个，第一是标记和清除这两个过程的效率其实都不高；第二是清除后可能会产生大量不连续的内存碎片。

**第二种是“复制”算法**。它将可用内存分成大小相等的两块，每次只使用其中的一块。当发生垃圾回收时，先将仍然存活的对象复制到另一块，然后把这一块的内存全部清理掉。它的优点是不会产生内存碎片。缺点是可用内存缩小了一半，并且如果对象存活率高，就需要进行较多的复制操作，效率降低。

现在的商用虚拟机都采用这种算法来回收**新生代**。按经验值，新生代有98%的对象都是“朝生暮死”的，因此将新生代内存空间划分为3部分，**Eden区**占其中的80%，然后有两个各占10%的**Survivor区**，每次只使用Eden区和一个Survivor区。如果某次回收有超过10%的对象存活，Survivor空间就会不够用，此时就需要老年代进行“分配担保”，临时借用一些内存空间存放多出的存活对象。

**第三种是“标记-整理”算法。**先标记可回收的对象，然后将所有存活对象都向一端移动，最后清理掉最后一个存活对象之外的内存空间。

**第四种是“分代收集算法”。**根据对象存活周期的不同，将内存划分为“新生代”和“老年代”，然后根据各个年代的特点采用最适当的收集算法，比如新生代采用“复制”算法，老年代因为对象存活率高，所以采用“标记-清理”或“标记-整理”算法。

**Q: 垃圾收集器有哪些？**

**Serial收集器**。

当它进行垃圾收集时，会暂停其他所有的工作线程，也就是“Stop The World”，这会引发很差的用户体验。但它也有优点，比如简单高效。

**ParNew收集器。**

它是Serial收集器的多线程版本，除了支持多线程，其余方面和Serial收集器无太大差异。它是许多运行在Server模式下的虚拟机中首选的新生代收集器。随着CPU数量的增加，它进行GC时对系统资源的有效利用还是有好处的。

**Parallel Scavenge收集器**

它是一个新生代收集器，使用复制算法，也是多线程的。它与其他收集器相比有一个特点，其它收集器的关注点是尽可能缩短在GC时用户线程的停顿时间，而这个收集器关注的则是达到一个可控制的“吞吐量”，也就是用户线程的运行时间跟总时间的占比。前者适合需要与用户交互的程序，达到良好的响应速度以提升用户体验；后者则适合不需要太多交互，而需要尽快完成运算的后台任务。

**Serial Old收集器**

**Parallel Old收集器**

**CMS收集器**

**G1收集器**

Q: CMS收集器是什么？它的运作过程是怎样的？它的优缺点是什么？

CMS收集器全称是Concurrency Mark Sweep收集器，也就是并发标记清除收集器。它以最短回收停顿时间为目标。

它的运作过程分为4个步骤：

1. 初始标记：只是标记GC Roots直接关联的对象，速度快。
2. 并发标记：进行GC Roots Tracing，也就是标记GC Roots的所有间接关联、可达的对象。
3. 重新标记：由于并发标记期间Gc线程和用户线程是并行的，所以重新标记就是修正由于用户线程执行所引起的标记变动。
4. 并发清除：顾名思义。

其中，初始标记和重新标记仍然会触发STW，但这两个步骤的执行时间极短；另外两个步骤是和用户线程并行的，所以整体上，GC所引起的停顿很短。这是它的优点。

它的缺点是：

1. 对CPU的资源敏感，如果CPU资源不够，它虽然不会造成长时间停顿，但会拖慢用户线程的进展速度，总吞吐量就会降低。
2. 由于它是和用户线程并行的，因此在它的三次标记动作执行过后，用户线程还有可能会产生新的垃圾，这部分垃圾只能留到下次GC时再清除。
3. 它采用标记-清除算法，会产生空间碎片。

Q: G1收集器是什么？

Q: JVM的Client模式和Server模式的区别是什么？

**Q: GC日志如何阅读？**

```
2021-09-09T14:44:04.813+0800: 0.163: [GC (Allocation Failure) 
2021-09-09T14:44:04.813+0800: 0.163: [DefNew: 139776K->17472K(157248K), 0.0164545 secs]  139776K->45787K(506816K), 0.0165501 secs] [Times: user=0.00 sys=0.02, real=0.02 secs] 
```

要点：

1. 2021-09-09T14:44:04.813+0800，这部分是GC事件发生的时间点。
2. 0.163是GC事件相对于JVM启动的时间间隔，单位秒
3. [GC，用于区分minorGC和fullGC
4. (Allocation Failure) 失败原因，这里是因为年轻代没有足够空间存放新对象。
5. [DefNew，垃圾收集器的名称
6. 139776K->17472K(157248K)，年轻代GC前、后的使用量，以及年轻代的总容量。
7. 0.0164545，GC持续时间
8. 139776K->45787K(506816K)，整个堆内存的使用情况
9. [Times: user=0.00 sys=0.02, real=0.02 secs]，用户态、内核态消耗的CPU时间，以及GC从开始到结束所经过的墙钟时间，包括运算时间和阻塞时间。

**Q: 说说对象的内存分配和回收策略。**

1. 在多数情况下，新对象优先在新生代的Eden区分配，若Eden区空间不够，则虚拟机将发起一次Minor GC
2. 长期存活的对象将进入老年代。年龄默认是15岁，有参数设置。
3. 年龄也并非固定死的，而是可以动态判定的。比如，当Survivor空间中相同年龄的对象大小总和超过该空间的一半，年龄大于或等于该年龄的对象就直接进入老年代。
4. 大对象，也就是需要大量连续内存空间的对象，直接进入老年代。所以我们写程序时应尽量避免创建短命的大对象。
5. 空间分配担保：对新生代gc之前，先检查老年代的最大的连续内存空间容量是否大于新生代的所有对象大小，或者是否大于历次晋升老年代的对象的平均大小，如果检查通过，则触发minor gc，否则触发full gc。

## 性能监控和故障处理工具

**Q: 举例说说jdk自带了哪些监控和故障处理工具？**

有若干个命令行工具，具体不记得了，功能有内存映像、dump分析、堆栈跟踪、生成代码反汇编等。另外有两个可视化的工具，分别是JConsole和visualVM，这俩几乎包含了前面的命令行工具的所有功能。

**Q: JConsole有哪些用途？**

用途很多，比如查看内存各个区的变化趋势，查看线程快照，进行死锁分析等。

**Q: visualVM有哪些用途？**

java官方对这个软件的描述是all-in-one，意思就是说它包含了全部的功能，比如运行监视、故障处理、性能分析等。它可以用于生成和分析堆dump文件，分析OOM有用；找出调用次数最多、或运行时间最长的方法，这对性能定位有用；还可以通过安装插件扩展更多的功能。

## 类加载机制

**Q: 类从被加载到虚拟机内存开始，到卸载出内存为止，它的生命周期包括哪几部分？其中哪几部分属于类的加载过程？**

包括：

1. 加载
2. 连接（验证、准备、解析）
3. 初始化
4. 运行（使用）
5. 卸载

**Q: “连接（Linking）”是指什么？**

**Q: 哪5个阶段的顺序是确定的？**

加载、验证、准备、初始化、卸载

**Q: 哪5种情况下必须对类进行初始化？也就是对一个类进行“主动引用”？**

1. 遇到new, getstatic, putstatic, invokestatic指令时。比如使用new创建对象；读取或赋值一个类的静态变量（用final修饰的常量除外）；
2. 使用反射调用类；
3. 当初始化一个类时，其父类还没初始化的情况下。
4. jvm启动时main方法所在的类；
5. 和动态语言有关的，如果对一个java.lang.invoke.MethodHandle实例的解析结果...

**Q: 被动引用有哪些例子？**

1. 通过子类引用父类定义的静态变量，子类不会被初始化；
2. 通过数组定义引用类，不会导致该类被初始化；
3. 使用一个类所定义的常量，不会导致该类被初始化。

**Q: 类的加载阶段需要做哪几件事情？**

1. 根据一个类的全限定名获取这个类的二进制字节流
2. 从这个字节流中解析出静态存储结构，转化为方法区的运行时数据结构
3. 创建一个class对象，作为方法区中这个类的相关信息的访问入口。

**Q: 类加载器的作用是什么？**

根据类的全限定名，获取描述这个类的二进制字节流，这个动作是被规定可以在虚拟机外实现的，以便二进制字节流的来源和获取方式可以按需灵活实现，实现这个动作的程序就叫做类加载器。

**Q: 双亲委派模型说的是什么？它的好处是什么？**

要回答这个问题，首先需要说说类加载器的层次关系。

jvm系统提供了3个类加载器，分别是启动类加载器，扩展类加载器，应用类加载器，这3个加载器自上而下形成父子关系，分别有自己的类搜索路径。在应用类加载器之下，还可以自定义多个自己的类加载器。

以上是类加载器的层次结构，接着说说双亲委派模型的工作流程：当一个类加载器需要加载一个类时，它首先不会自己加载，而是委托父加载器加载，这样，任何类的加载请求，都会传递到最顶级的启动类加载器这里。如果启动类加载器在自己的搜索范围内找不到需要加载的类，才会把请求下放给自己的子加载器。

这样做有一个好处，就是保证类的相等关系的稳定性。比如Object类，不管由哪个类加载器加载，最终都会传递给启动类加载器，从rt.jar包里头加载。这样就能保证程序中各处出现的Object类都是同一个类。

Q: 双亲委派被破坏

历史上有3次，或5次。

第一次是历史遗留问题，双亲模型还没推出的时候，就已经有自定义类加载器了，类加载器直接重写了ClassLoader的loadClass方法。双亲模型推出后，推荐重写findClass方法。

第二次是JNDI，JDBC等需要加载SPI（Service Provider Interface)实现的场景。以JDBC为例。我们获取一个数据库Connection，是调用DriverManager.getConnection方法获取的。

```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql", "root", "1234");
```

DriverManager是BootStrap加载器加载的，由于加载器采用的是全包加载机制，所以DriverManager所需要的Driver实现类理应也是由BootStrap加载。但BootStrap无法加载这些第三方实现类，所以Java设计者就开了一个口子，允许从当前线程获取一个上下文加载器，可以指定，如果没有则从上级线程获取，如果还获取不到就默认为App加载器，由这个加载器加载这些Driver实现。

第三次则是用户对程序的动态性追求导致的，用户希望实现类修改后，无需重启程序就能生效，类似于热插拔的机制，相关的**代码热替换**、**模块热部署**技术也破坏了双亲机制。

**Q: OSGi的类加载器架构是什么？（第9章）**

## 虚拟机字节码执行引擎

**Q: 栈帧是什么？它包含哪些内容？**P236

当方法A调用方法B时，会创建一个方法B对应的栈帧，然后压到虚拟机栈里头。创建的方法B栈帧包含有方法B的局部变量表，操作数栈，动态连接和方法返回地址。

## Java内存模型（JMM）

**Q: 为什么要定义JMM，JMM的主要目标是什么？**

为了封装应用程序和不同的操作系统、底层硬件之间内存交互的差异性，所以定义出JMM。

~~JMM的主要目标是规定好对象和内存之间的交互。~~

JMM的主要目标是规定虚拟机如何将变量存储到内存，以及如何从内存中取出变量，这样的底层细节。

**Q: JMM分为哪几部分？**

每个线程都有自己的私有工作内存，各个线程的私有缓存通过load、write操作和一个公共的主内存进行数据交换。

**Q: 主内存和工作内存之间如何交互？这些交互有哪些规定限制？**

1. 针对主内存，有lock和unlock操作，用于锁定和解锁对象，实现线程对对象的独占性访问，也就是同步
2. load操作从主内存中取出变量的值，放入工作内存里
3. load2操作取出load操作放入工作内存的值，放入工作内存的变量拷贝里，当遇到读取变量值的字节码指令时触发该操作。
4. assign操作将新值写入到工作内存的变量里，当遇到写入变量值的字节码指令时触发该操作。
5. write2操作将assign的值挪到主内存里

限定规则有：

1. 没调用过lock操作的对象不允许调用unlock操作
2. 对象必须从主内存创建，不能直接从工作内存创建；也就是说，在assign、write操作之前，必然有load操作

思路回答法：

我记得一共有8个操作，以及8个限定规则，但具体细节记不清楚了，所以这里我只回答一下基本思路：

首先由lock和unlock操作，针对主内存的对象，这个是用于实现同步的。

然后，有load操作，它分为两个操作，就叫load1和load2吧。load1是指将变量的值从主内存取出，传输到线程的工作内存里；load2则是将load1放进来的值赋值到工作内存的变量拷贝里。

然后，当虚拟机执行读取变量值的指令时，就会对工作内存的这个变量进行use操作；

然后，当虚拟机执行写入变量值的指令时，就会对工作内存的这个变量进行assign操作；

assign操作之后，不是说紧随其后，只是说在之后，必然会发生store操作，将工作内存的这个变量的值，复制传输到主内存。

然后，在主内存执行write操作，将store放入主内存的值赋值到主内存的变量里。

**Q: volatile关键字有什么作用？**

有两方面的作用：

1. 从效果上，任意线程，只要对volatile变量更新赋值，该更新立刻在主内存生效，其它线程对此立刻可见；
2. 限制指令重排序，从字节码指令的层次看，在变量赋值指令之前的所有指令，都不能排到后面去，同样的，后面的指令也不能排到前面去。这个的典型应用就是使用双重检查机制的单例模式。

**Q: 对volatile变量所做的操作都是原子的吗？**

不是。volatile有以上两个作用，但这并不意味着对它的操作都是原子的。比如一个i++ java语句，在字节码层面是拆分成3条指令的，若不采用同步，由多个线程并发执行此java语句，那么i的最终值是无法预期的。

**Q: 对于long，double类型的变量有什么特殊规则？**

对于一般的基本变量，读写操作都是原子的，而long，double变量例外。但这个例外也只是规范上不做限制，实际上是罕见现象，一般的虚拟机实现都将他们也实现成原子的。

**Q: JMM在并发过程中做到的“3性”是什么？如何做到的？**

一、原子性。对基本类型变量的读写都是原子的，虽然long和double有点例外，但可以忽略。

二、可见性。指一个线程对共享变量进行修改，这个修改对其它线程是立即可见的。volatile关键字、final和synchronized都能做到这一点。

三、有序性。即避免指令重排序对结果产生影响。在单线程内，所有的指令都是天然有序的，而如果在一个线程观察另一个线程时，另一个线程执行的指令是无序的。可以通过volatile和synchronized关键字实现有序性。

Q: volatile，final和synchronized是如何实现立即可见性的？

**Q: 什么是先行发生原则？**

假设有操作A和操作B，分别在不同的线程执行，如果从时间轴的角度看，操作A是先于操作B发生的，那么操作A所产生的影响（比如更新了共享变量，调用了方法），操作B是可以感知到的。这种情况下我们就说这两个操作满足了先行发生原则。

**Q: 有哪些“天然的”先行发生关系？**

记得有8个：

1. 在一个线程内执行的代码，前面执行的代码先行发生于后面执行的代码。
2. 对同一个锁，释放锁的操作先行发生于后面获取锁的操作。
3. 对volatile变量的写操作先行发生于后面对该变量的读操作
4. 线程的start方法先行发生于线程的内部代码
5. 线程的内部代码线性发生于线程的终止检测动作
6. 线程的interrupt方法调用先行发生于被中断线程对interrupted状态的检测
7. 对象的初始化（构造方法执行完成）先行于它的finalize方法执行
8. 传递性，如果A先行于B，B先行于C，那么A先行于C。

Q: 先行发生是否代表“时间上先发生”？“时间上先发生”，是否代表先行发生？

## Java线程

**Q: 实现线程有哪些方式？各有什么优缺点？**



**Q: Java线程的实现方式是什么？**

在内核态，n个CPU内核，通过线程调度器，可以分为m个内核线程，内核线程一对一对应到用户态里头的轻量级进程，一个轻量级进程就是一个java线程。

这种模式下，java线程的创建、销毁、切换等不需要内核态的支持，所以相对高性能；同时，java线程和cpu核心的映射，也可以通过内核线程提供支持，这样就能较为充分地利用硬件资源，减少线程被阻塞的风险。

**Q: 线程调度有哪些方式？各有什么优缺点？**

线程调度主要有两种方式：

1. 协同式调度
2. 抢占式调度。

协同式的缺点是线程的执行时间多长，什么时候释放自身，切换执行下一条线程，是由本线程自己决定的，这样容易导致整个程序阻塞，不稳定；抢占式的优点则是线程的执行时间、线程间的切换由系统调度决定，相对可控。

java采用的是抢占式调度，但是也可以指定线程优先级。

**Q: Java线程如何划分优先级？**

**Q: Java线程有多少种状态？状态之间如何转换？**

有5种，或者6种状态，区别是有个等待状态，它分为限期等待和无限期等待两种类型。下面从6种状态的角度出发，解释一下状态之间如何切换：

1. 线程new出来后，进入了**新增**状态
2. 线程start方法被调用后，该线程进入“**可运行**”状态，等待系统调度
3. 线程被调度后，进入**运行中**状态。
4. 运行中的线程，自己调用了sleep，指定了时间，就进入**限期等待**状态
5. 限期等待中的线程，等待时间过后，回到“可运行”状态
6. 运行中的线程，自己调用了锁对象的wait，不指定时间，就进入**无限期等待**状态
7. 如果有线程调用了同一个锁对象的notify方法，就会唤醒前面说的无限期等待状态线程，进入“可运行”状态
8. 线程运行结束，进入**结束**状态。
9. 运行中的线程，申请不到锁，就陷入**阻塞**状态，等待锁被释放然后自己抢占。

## 高效并发

**Q: 什么是线程安全？**

当多个线程同时访问一个对象时，如果访问线程不需要采取任何的额外同步手段，就能保证获取到正确的结果，那么就说这个对象是线程安全的。

**Q: 按照“安全程度”由强到弱来排序，对被操作的共享数据可以分为哪几类？**

1. 不可变对象。比如String对象
2. 绝对线程安全。找不到例子
3. 相对线程安全。我们声称的线程安全类都属于这种类型，比如Vector，HashTable，Collections.synchronizedCollection方法包装后的集合对象等
4. 线程兼容（非线程安全），比如ArrayList，HashMap
5. 线程对立。说的是尽管采用同步手段都保证不了安全的，一般比较少见，比如线程的suspend和resume方法等。

**Q: 使用线程安全的类，一定不需要再额外采用同步手段了吗？举一个反面例子。**

不一定。比如Vector对象，它是线程安全的。如果一个线程通过索引下标删除其中的元素，另一个线程通过索引下标读取其中的元素，不采用同步手段锁住vector对象的话，就可能会发生数组越界异常。原因是vector的remove，get方法虽然内部采用了同步措施，但索引下标不是vector的内部属性，却是影响整个程序状态的变量，所以...

**Q: 线程安全的实现方法有哪些？**

**Q: 加锁有哪些性能开销？**

**Q: 锁优化有哪些方式？**

# 数据库

## 基础

**Q: 三范式**

1. 第一范式，一个字段不可再分。
2. 第二范式，非主属性不能对主键存在部分函数依赖。比如有主键（学号，课程号），姓名只依赖学号，学分只依赖课程号。若不符合这个范式，则会产生数据冗余。解决方法是拆成两张表。
3. 第三范式，非主属性都和主键直接相关，不存在传递依赖。
4. BC方式，主属性也都和主键直接相关，不存在传递依赖。

## 索引

Q: 使用索引的目的是什么？

磁盘块是磁盘和内存之间传输数据的基本单位，定位并传输一个磁盘块所需时间一般是毫秒级的，与CPU处理内存数据相比，这个级别的耗时是相当长的。因此，磁盘IO是数据库的一个主要性能瓶颈，使用索引的目的，本质上就是减少磁盘IO，尽可能使得磁盘和内存之间的块传输次数减到最小。

Q: 说说主索引呗。

主索引建立在数据表的排序码字段上。

数据表的排序码字段的值是唯一的，并且排序和数据记录的物理顺序相同。

把主索引定义为一张包含两个字段的表，或文件，第一个字段的数据类型和排序码数据类型相同，第二个字段存储磁盘块指针。

将数据表中每一个磁盘块的第一条记录 的排序码值，以及地址值作为主索引的索引项按顺序存储。

当需要按指定排序码值查找记录时，用二分法查找主索引，定位到目标值所属的磁盘块，再将磁盘块送到内存中线性查找出目标记录即可，相比于线性查找数据表，使用主索引减少了块访问次数，提升响应速度。

由于在数据表中只有部分记录在主索引中存在对应的项，因此主索引是稀疏索引。

Q: 【计算】假设块大小B=1024byte，存储在磁盘上的数据表（有序文件）包括r=30,000条记录。文件记录定长且不跨块。记录长度R=100byte。文件的快因子（每块包含的记录数，bfr）是多少？该表需要多少个块来存储？在表中进行二分查找需要多少次块访问？如果排序码字段长度为9byte，块指针长度6字节，创建了**主索引**后，查找记录所需的块访问次数又是多少？

文件的块因子(bfr) = floor(B/R) = 10;

该表占用的块数(VAR2) = ceil(r / bfr) = ceil(30000/10) = 3000;

在表中进行二分查找需要的块访问次数(VAR3) = ceil(log(2, VAR2)) = 12

索引项长度 = 9 + 6 = 15

索引块因子 = floor(1024 / 15) = 68

索引项数量=表占用块数=3000

索引占用块数 = ceil(3000/68) = 45

索引查找块访问次数 = ceil(log(2, 45)) + 1 = 7

**相比直接在表进行二分查找的12次块访问，减少了5次。**

Q: 再说说聚簇索引呗。

如果建立索引的字段，在数据表中是按记录的物理顺序排序的，但它的值不唯一，这个索引就是聚簇索引。

由于一个表最多只能有一种物理排序方式，所以一个表最多只能有一个主索引或一个聚簇索引。

Q: 聚簇索引面对数据增删会带来什么问题？如何解决？

由于用作索引的字段是有序的，因此为了在正确的位置插入记录，免不了移动表中的已有数据，这可能会改变某些块的锚记录，需要顺带修改索引项。

常见的解决方法是为每一个值预留一个整块（或若干个连续的块），所有取该值的记录都放在那个相应的块中。

**Q: 再说说辅助索引呗。**

辅助索引基于表的**非排序字段**建立，可以是候选码或非码字段。索引同样定义了两个字段，第一个字段类型和索引字段类型一致，第二个字段是一个指向表记录所在的磁盘块指针，或者是记录指针。

由于不涉及物理排序，所以一个表可以有多个辅助索引。

辅助索引有两种建立方式：一、对每个记录建立一个索引项，此时辅助索引是稠密索引；二、对索引字段的每个值建立一个索引项，索引指针指向一个中间磁盘块，中间磁盘块存储的是索引值所对应的多条记录的指针，这种结构下，辅助索引是稀疏索引。

Q: 【计算】承接上面的计算例子，如果建立的是稠密辅助索引，那么通过索引查找记录涉及到多少块访问？

稠密辅助索引的索引项数 = 表记录数 = 30000

索引占用块数 = ceil(30000/68) = 442

索引查找块访问次数 = ceil(log(2, 442)) + 1 = 10

**虽然10次比主索引的7次要多。**

**但是，如果直接查表，就得线性查，平均块访问次数 = 3000/2 = 1500.**

**从1500降到10次，从这个角度看，辅助索引对性能的提升比主索引要大。**

Q: 为什么辅助索引对搜索时间的改善比主索引更加显著？

因为主索引基于排序码建立，如果没有主索引，仍然可以在表中进行二分查找；而辅助索引基于非排序字段，如果没有辅助索引，就得在表中进行线性查找，相比二分查找会带来更多的磁盘快访问次数。一旦使用了索引，都可以采用二分查找法查找，尽管辅助索引需要略多于主索引的块访问次数，但与各自直接查表的情况相比，辅助索引对性能的提升更多。

Q: 什么是多级索引？扇出（fo）是什么意思？

如上面所说，一级索引是一个，以索引字段值以及对应的指针作为索引项，将索引项按字段值进行排序，所形成的有序文件。可以基于这个有序文件，再建立一个索引文件，成为二级索引。进一步的，可以对二级索引再建立三级索引，以此类推，直到最后建成的索引文件只占用一个磁盘块，这称为顶级索引，所有的索引层次就组成了多级索引。

顶级索引有n个索引项，n就是多级索引的扇出。顶级索引的n个索引项，对应于次级索引的n个磁盘块。同样的，次级索引最多也有n个索引项，对应于次次级索引的n个磁盘块，以此类推，最后到达了1级（也就是最末级）索引，索引项的指针指向具体的记录。

一级索引用二分法定位数据，块访问次数是log(2,n)级别，而多级索引的块访问次数是log(扇出, n)级别。

Q: 【计算】承接上面的计算例子，如果对稠密辅助索引转换成多级索引，那么通过索引查找记录涉及到多少块访问？

第1级有442个块，第2级有7个块，第3级有1个块，所以次数=3+1=4.

Q: 子树的精确递归定义是什么？什么是内部结点？



Q: p阶搜索树是什么样子的？有什么约束条件？平衡树是什么意思？平衡有什么好处？搜索树存在什么问题？如何解决？

Q: p阶B树是什么样子的？

除根节点外，

Q: 【计算】假设搜索字段的长度V=9字节，磁盘快大小B=512字节，记录指针大小Pr=7字节，块指针大小P=6字节。对于p阶B树，根据上述条件，p的最大值能取多少？如果要求节点填满度为69%，树有3层，那么每一层有多少个结点，多少个项和多少个子树指针？

磁盘块大小 = $(p-1)*(9+7) + p*6 = 512$

算得P刚好等于24。考虑到处理算法的需要，可能存在父结点指针，节点中存在的项数等冗余信息，因此将p算作是23.

考虑填满度后，$p = p*0.69 = 16$ (向上取整)，也就是每个节点有16个子树，15个项。

树有3层，那么就考虑0,1,2,3层。

| 层号 | 节点数 |  项数 | 子树数 |
| ---- | -----: | ----: | -----: |
| 0    |      1 |    15 |     16 |
| 1    |     16 |   240 |    256 |
| 2    |    256 |  3840 |   4096 |
| 3    |   4096 | 61440 |     -- |

项数（记录指针数）合计：15+240+3840+61440=65535

[手工体验一下B树的逻辑](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

Q: B+树和B树的区别是什么？

Q: 【计算】承接上面例子，对于p阶B+树，p的最大值能取多少，意味着什么？叶子节点最多能容纳多少项？如果填满度为69%，树有3层，那么每一层有多少个结点，多少个项和多少个子树指针？

磁盘块大小 = $(p-1)*(9) + p*6 = 512$

算得p=34. **这意味着对比B树，内部结点有更大的扇出，更多的项数。（34 VS 23）**

假设叶子节点最多容纳p项，则 $p(9+7)+6=512$

算得p=31

填满度69%，也就是内部节点有23个指针（这里又向下取整了，😅），22个值；叶子节点有21个数据记录指针。

| 层号 | 节点数 |   项数 | 子树数 |
| ---- | -----: | -----: | -----: |
| 0    |      1 |     22 |     23 |
| 1    |     23 |    506 |    529 |
| 2    |    529 |  11638 |  12167 |
| 3    |  12167 | 255507 |     -- |

**255507 VS 65535，意味着B+树比B树能容纳更多的记录指针。**

Q: 组合索引（复合索引）是什么？

组合索引是多字段索引，索引结构和单字段索引一样，只不过排序值是对应字段值组成的元组。因此建立组合索引需要注意字段的排序，符合最左匹配原则。

**Q: 什么是最左匹配原则？**

假设有一个复合索引，字段有F1，F2两个，字段顺序是F1，F2。F1的值是有序的，在某一个给定的F1的值里头，F2的值也是有序的，但从整个索引表看，F2的值是无序的。

由此可以看出，如果查询条件只包含F1，那么就可以通过二分法查询索引，索引可被高效使用；如果查询条件同时包含F1和F2，那么也可以通过二分法查询索引，索引可被高效使用；而如果查询条件只包含F2，就无法通过二分法查询索引，索引不能被高效使用。

## 事务

**Q: 事务的ACID是什么？**

原子性，一致性，隔离性，持久性

[事务ACID理解](https://cloud.tencent.com/developer/article/2151355)

**Q: 多个请求同时读写同一块数据，可能会产生什么问题？**

可能造成的问题有：

1. 脏读
2. 不可重复读
3. 幻读
3. 丢失更新（第一、二类）

[多请求读写同一数据可能产生的问题](https://cloud.tencent.com/developer/article/1450773)

===== 脏读 =====

所谓脏读，是事务A读到了事务B的未提交的数据。解决方式是将**事务隔离级别**设置为”读已提交“。

======= 不可重复读 =======

不可重复读，是事务A读取了某一行数据后，事务B更新了同一行数据，然后事务A重新读取同一行数据，却发现同一行数据变得不一样了。

这造成的问题可能有：1）事务A第一次读取了数据后，拿着该数据去进行其他操作，可能会导致数据不一致的范围扩大；2）事务A第二次读取了数据后，发现和第一次不一致，会造成疑惑。

解决这个问题的方式是事务隔离级别设置为”可重复读“。

======= 幻读 =======

幻读和不可重复读的相似之处是，第一次读取和第二次读取的数据不一样。区别在于，不可重复读针对的是同一行数据，而幻读针对的是同一查询范围的数据，也就是说，使用同样的查询条件，第一次查询和第二次查询，返回的结果行数不一致。

它造成的问题和不可重复读是一样的。

幻读产生的原因是行锁只能锁住行，从纯技术的角度出发没有100%的解决方案，需要根据具体的情况，采用以下措施：

1. 事务隔离级别设置为”串行化“，这样每个事务都是按顺序串行执行的，但这样做开销很大，性能很低，一般很少使用

2. 如果事务采用”读快照“的策略，可通过MVCC机制，可以一定程度上避免幻读问题。

3. 如果事务采用”读实时“的策略，可通过一种叫”间隙锁“的东西，一定程度上避免幻读问题。关于间隙锁，我理解的不深入，它会影响并发度并可能会导致死锁，我个人认为尽量别用。

4. 优化程序，减少事务的大小，从而减少事务之间的竞争，降低幻读产生的概率。（这是我认为的最实在的策略）

[幻读解决](https://www.cnblogs.com/jian0110/p/15080603.html)

[幻读解决2](https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB)

**Q: 事务的传播特性是什么？**

事务的传播特性是一系列配置配置项（共7种），规定事务如何在方法调用之间传播。

举个例子，方法a调用方法b，方法b自己创建了事务（创建事务的时候指定了传播特性）：

传播特性设置为 required: 如果方法a在事务内调用方法b，则方法b的事务沿用方法a的事务，否则方法b另起一个事务。

传播特性设置为 supports：如果方法a在事务内调用方法b，则方法b的事务沿用方法a的事务，否则方法b不创建事务。

传播特性设置为 requires_new：方法b一定是新建事务执行，如果方法a在事务内，则暂停方法a的事务。

以上3种是用得比较多的，其余4种记得不太清，通过上网搜索很容易搜到。

-----

现在考虑方法B的事务传播特性分别设置为以下七点时所发生的情况：

1. **PROPAGATION_REQUIRED**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则方法B新建一条事务执行。
2. **PROPAGATION_SUPPORTS**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则方法B不在事务中执行。
3. **PROPAGATION_MANDATORY**: 若方法A在一个事务内执行，方法B就在这个事务内执行，否则抛异常。
4. **PROPAGATION_REQUIRES_NEW**: 方法B总是新建事务执行。若方法A已在一个事务内，则暂停方法A的事务。
5. **PROPAGATION_NOT_SUPPORTED**: 方法B始终不在事务中执行。若方法A已在一个事务内，则暂停方法A的事务。
6. **PROPAGATION_NEVER**: 方法B始终不在事务中执行。若方法A已在一个事务内，则抛出异常。
7. **PROPAGATION_NESTED**: 若方法A在一个事务内执行，方法B就建立一个嵌套事务执行，如果没有事务按着required执行，开启单独的事务。在嵌套事务开始时将建立一个保存点，如果嵌套事务失败，我们将回滚到该保存点，内部事务的回滚对外部事务没有影响。

注意 PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的区别：

1. 前者是启动一个独立的事务，它的提交和回滚是完全独立的
2. 后者是启动一个“子事务”。子事务提交了，其结果仅在事务A中可见，直到事务A提交了，其结果才能被事务外所见
3. 若事务A回滚了，所有的子事务也回滚

## SQL

**Q: sql调优（持续研究）**

1. 不要用 select *
1. 用exist 代替 子查询
1. 用适当的 join 代替 子查询
1. 尽量用where代替having，原因是where在聚合前过滤记录，having则是先聚合所有记录，再过滤。
1. 给需要的列创建索引
1. 如果不要求去重，使用union all 替代 union
1. 避免用!=，它无法使用索引，可以用 or 替代

[having](https://blog.csdn.net/qq_37634156/article/details/120055284)
[sql调优](https://developer.aliyun.com/article/779151)



Q: SQL调优的过程是怎样的？

1. 首先，SQL调优的第一步是识别出慢查询语句，可通过分析慢查询日志、业务日志文件，结合代码阅读等手段找出。该动作的发起可以是被动的，也可以是主动的。
2. 找到慢sql后，还需要确认慢sql执行时的环境信息，例如当时的系统负载、网络、并发量等。
3. 接着是sql语句本身的分析、优化阶段，主要是分析sql涉及的表结构、数据量、索引等，结合Explain，也就是执行计划进行分析。
4. 优化完毕后，进入结果验证阶段，包括模拟出发生问题时的环境信息、验证优化后性能、以及评估优化效果会不会随着系统演化，而退化，等。

以上就是SQL性能调优的整体过程，我想你们问题的重点应该在第3点，也就是分析执行计划、sql优化策略这方面，接下来是否需要展开说说？

---------

开场白描述：

拿到慢查询sql后，分析它的执行计划：

1. 观察type和key值，如果有出现All和null，表明没有使用索引。同时看rows值，如果有很多行，表明预计全表扫描大量的数据行，此时应该考虑进行索引优化。
2. 没有使用索引原因：
   1. 比如没有建索引
   2. 建立的索引不符合最左前缀匹配原则
   3. 第一列使用了!=号
   4. mysql判断直接全表扫描比使用索引更好时（检索比例，也就是特定的值的行数占全表总行数的比值）
   5. 在索引列使用了函数，或者做计算，类型转换
3. 如果type的值是range，表明使用了范围查询，同时观察key_len值，可以据此得出查询使用了组合索引的前几列，在范围查询后面的列就不会使用到。用like模糊匹配时，%如果写在左边，这一列也不会被用到，索引覆盖除外。
4. 索引也不是越多越好，太多索引会影响数据增删改的性能。可以观察possible_keys的值，如果有太多索引，意味着里头可能有无效的、重复的索引，应该进行梳理，去掉没有用的索引。
5. 最后也要留意一下extra列。
   1. 如果值为using index，表明使用了覆盖索引，这是性能高的表现，平时避免写select *；
   2. 相对应的是 using where，表明没有使用覆盖索引，mysql先读取整行数据，再检查是否符合where条件，符合留下，不符合则丢弃。这种情况需要通过调整索引来优化；
   3. using temporary，表明查询过程中创建了临时表，比如使用了distinct、子查询等。这是需要优化的情况。
   4. using filesort，表明mysql并没有按索引顺序从表中读取行，而是先读取所有符合条件的行，再按排序条件检索的，这也是需要优化的情况。

Q: Explain有哪些信息？

我们首先会拿到一段复杂查询SQL。所谓复杂查询，就是指一段很长的select语句，它包含各种join，以及子查询等。对它执行Explain，就能得到执行计划信息，包括

1. id：查询的顺序号，有几个select就有几个id，它的顺序是随着select的出现增长的，值越大的select越先执行。
2. select_type:就是select_type，查询类型，它的值有simple，primary，subquery，derive, union, union result等
3. table：当前select查询的表，可以是真实表名，也可以指向derive或subquery子查询的id
4. type：这个type表示select的访问类型或者关联类型，access type或join type.
5. possible_keys: 这个查询可能会用到哪些索引。如果太多，则考虑是否有重复的，或无效的索引。
6. key: 查询实际用到的索引。一般一个查询只会用一个索引，除了少数情况用到了合并索引。
7. key_len：在索引中被使用的字节数，据此可推测出使用了索引的哪几个列。
8. ref：表示常量值，或者哪些字段，在查询中用于和索引比较。
9. rows: 表示mysql估计需要查询的行数。
10. extra: 包含一些额外信息，表示mysql会如何解析这个查询。

[腾讯云的一篇对explain的介绍文章](https://cloud.tencent.com/developer/article/1730827#:~:text=Explain%E8%A2%AB%E7%A7%B0%E4%B8%BA%E6%89%A7%E8%A1%8C,%E6%94%BE%E5%85%A5%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%AD%EF%BC%89%E3%80%82)

[MySql8.0官网对explain的介绍](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)

[这个也看下，作为优化案例的练习](https://developer.aliyun.com/article/939447)

Q: select_type的几个值展开说说

1. simple，就是简单的查询，不包含union和子查询
2. primary，最外层的查询
3. subquery，不在from里面的子查询
4. derive，在from里面的子查询
5. union，这个查询是union中的第二个或第二个以后的查询
6. union result，这个查询是由哪些子查询union产生的，值的形式为<union*`M`*,*`N`*>

Q: table展开说说

它的值可以有三种情况：

1. 就是具体的表名
2. 如果是union结果，那么就是<union id1, id2> 的形式
3. 如果from里头有子查询，那么就是 <deriveN> 的形式
4. ~~如果其他地方有子查询，那么就是<subqueryN>的形式~~

Q: 索引的基数，Cardinality，含义是啥？

索引列的基数的含义是，这个字段的唯一值的数量。基数越高的索引越容易被使用。

但这只能做参考，不是绝对的。索引是否被使用，还得看“选择性”，所谓选择性是指一个确定的值，和表的总行数的比值，比值为1是最理想的。由于选择性的不同，会出现两条结构相同，但查询条件值不同的select语句，使用的索引不一样的情况。

Q: 模糊查询，通配符若放在左边，索引将失效，如何解决

两种方式：

1. 增加冗余字段，存储这个字段的reverse值，模糊查询就查这个冗余字段，并把%放在后面
2. 使用覆盖索引，主要是不要用select *

如果对列使用了函数，例如Upper(name)，那么定义在name上的索引将不会被使用。

Q: 使用唯一索引的好处是啥？（P72）

MySql利用唯一索引匹配到一行记录后，就自己返回了。

Q: sort_range, sort_rows是啥？

它是show status命令结果出来的两个变量，具体没了解过，后面需要补充这个知识缺口。

Q: Not Null 的优点？

如果明确一个列不会存在一个未知的值，那尽量使用 NOT NULL，如果这样的字段在索引中，那么该字段将会占用更小的空间，并简化索引的处理过程。

Q: DATETIME 和 TIMESTAMP的区别？

前者8字节，后者4字节，后者非空，适合存储总是有值的时间日期字段。

Q: 使用enum类型的优点

3个优点：

1. 它隐含了固定范围的完整性约束。
2. 它只需用1个字节存储了255个不同值
3. 它更具有可读性

Q: IP地址和MD5值用什么类型来存比较好？

IPv4地址用INT UNSIGNED存储，仅占用4字节，相比varchar(15)可以节约2/3的存储空间，并且有专门函数用于IP和字符串之间的转换。

IPv6是128bit的，用BINARY(16)类型存储。

MD5也推荐用BINARY(16)来存储，有专门的函数用于将在数字和字符串之间转换。

Q: 全文索引

```sql
alter table fulltext_test
    add fulltext index content_tag_fulltext(content,tag);
```

again, match

```sql
select * from test where match(content) against('aaaa');
```

布尔全文索引

```sql
select * test where match(content) against('a*' in boolean mode);
```

[ref](https://zhuanlan.zhihu.com/p/35675553)

Q: 金蝶工作中不常用的sql

explain select name_3,name_4 from test_index_len **force index**(idx_name_3_name_4) where name_3='xxxx';

**SET** @var1 = 'sssss'

# 软件设计

Q-BEGIN

客户口头描述：

我们需要一个电子商务平台来销售产品。用户可以浏览商品、添加商品到购物车、结算购物车、查看订单等。我们需要一个后台管理系统来管理产品、订单和用户信息。

Q: 基于口头描述，进行建模。

Q-END

步骤: 

1. 确定系统参与者
2. 画用例图：也就是参与者对系统能做什么操作
3. 画类图：确定对象（数据和行为的封装）和对象关系
4. 画时序图：描述用例执行过程中，对象之间的交互。

**Q: 设计模式6大原则是？**

1. 单一职责
2. 里氏替换
3. 依赖倒置
4. 接口隔离
5. 迪米特法则
6. 开闭

里氏替换：子类可以扩展父类，但不能更改父类（原则）；可以将子类对象赋值给父类变量，并且不会报错。

依赖倒置：高层不依赖底层，两者依赖抽象；抽象不依赖具体，具体依赖抽象。**面向接口编程**，因为细节多变，而抽象相对稳定。以抽象为基础搭建起来的架构要稳得多。

接口隔离原则：将大接口拆成小接口，例如将整个学生成绩管理系统拆成输入、计算和输出（打印）三个接口。

迪米特法则：最少知道原则，类1调用类2，类1不需要知道类2的太多细节。类尽量内敛，非必须公开的都声明为private.

开闭原则：对扩展开放，对修改封闭。你不用修改它，你可以扩展它。前面的5个原则都是开闭原则的具体形态。

[设计模式——六大设计原则](https://cloud.tencent.com/developer/article/1764387)

[面向对象设计的六大设计原则](https://juejin.cn/post/6844903673672237063#heading-0)

**Q: 使用组合替代继承有什么好处？**

1. 父类的变化影响子类
2. 子类也许只需要继承父类的部分功能
3. 继承层次可能会越来越多
4. 现实世界中的事物，都是共性的少，差异的多
5. 思考组合替代继承，就是思考”是什么“能否替换成”有什么“。

**Q: 设计模式分哪几大类？**

1. 创建型
2. 行为型
2. 结构型

**Q: 桥接模式**

![image-20230325090624268](resources/image-20230325090624268.png)

1. 设计师着重思考红框的部分，客户端调用桥接器，桥接器持有实现者，注意面向接口设计，思考并识别出系统变化的多个维度（每个维度均可有不同实现，可通过配置灵活组装，无需重新编译程序）。
2. 思考完毕后，下面的实现可安排分工实现。
3. 对这个模式可以这样理解：一个类存在两个或多个独立变化的维度，通过组合的方式，让这两个或多个维度可以自己独立扩展。

可以使用动物世界来做比喻：

1. 动物有两种类型的行为：一个是运动，比如行走和飞行；一个是吃，比如吃肉和吃草。
2. 下面考虑4种典型动物：老鹰，牛，麻雀，狮子
3. 如果按照动物分类学的思路建模，自然就形成了继承模式。继承模式可以有2层，第一层是动物这个抽象，第二层是这四种动物；也可以有3层，第一层是动物，第二层是食草动物和食肉动物，第三层则是对应的具体动物。
4. 这里立刻就想到了一个问题，第二层为什么不是飞行和行走呢？如果是食草和食肉，那么就得在第三层实现飞行和行走的行为，造成重复代码。在这个例子中，变化的维度有2类，每一类有2种情况，所以变化总数是2*2=4。如果变化的种类有m类，每类n种情况，那么变化数就是m✖️n，庞大的继承体系就这样来了。
5. 因此不妨换个角度思考，从”是什么“换成”有什么“，建模就能形成组合模式。从抽象的角度看，就是动物，有运动和吃，这两种行为。动物抽象类关联一个运动接口，和一个吃接口就可以了。
6. 实现类的数量上，有4种动物实现类，以及两个运动实现类，和两个吃实现类，总共8个类。
7. 桥接模式的好处1是，如果需要增加一种变化维度，只需新定义一个接口，桥接器引用这个接口，并提供接口的对应实现类即可，不影响现有的变化维度。
8. 桥接模式的好处2是，如果变化维度值是不固定的，比如老鹰虽然是飞行的，但偶尔也会行走；或者杂食性动物既吃肉又吃草；或者需要增加一个”游泳“运动。那么在客户端初始化具体的动物时，按需构造对应的变化维度值赋值进去就可以了。
9. 可以看出，使用桥接模式，需要软件设计者能正确识别出一个业务主体所具有的变化维度，这是一项能力考验。在有了想法之后，快速进行沟通，评审确认。

[**多个特性不同时如何设计继承体系结构**](http://www.uml.org.cn/mxdx/201205215.asp?artid=6671)

# 架构

**Q: 系统的质量有哪些衡量指标？**

1. 可靠性，系统的操作是否能无差错，符合预期的能力
2. 高可用，当系统遇到硬件故障、网络故障、软件异常等问题时，能否快速恢复服务或提供无中断的服务。
3. 性能，系统能够在预期的负载下保持高效的响应速度和吞吐量
4. 可伸缩性，系统能否在负载增加的时候，仍然保持高效运行的能力
5. 安全性，系统能够保护用户的数据和隐私不受非法访问、篡改和破坏
6. 可扩展性，在不影响性能和可靠性的前提下，方便地扩展新功能
7. 可维护性，系统能够方便地进行修改、扩展和维护，并且不会影响系统的正常运行。
8. 易用性，系统提供简单、直观、易于操作的用户界面或操作流程，以便用户能够方便的使用系统

[系统的性能，可用性，可伸缩性，可扩展性的概念](https://liuhll.github.io/hexo-blog-deploy/2018/11/29/2018-11-ase-note/)

Q: 普通java工程师 vs 优秀架构师

[参考链接](https://cloud.tencent.com/developer/article/2241957)

# 分布式

**Q: ZK是如何实现分布式锁的？**

1. 客户端1往zk添加节点
2. 客户端1检查自己的节点的序号是否排最前，如果是，获取锁成功。这里先假设它获取锁成功了。
3. 客户端2也往zk添加节点，也检查自己节点的序号是否排最前，发现不是，就往自己所属节点的前一个节点设置监听器，同时获取锁失败，阻塞等待。
4. 客户端1处理自己的业务，处理完毕后，释放自己的zk节点
5. 客户端2的监听器感知到客户端1的节点已被释放，于是通知客户端2再次检查自己的节点是否排最前，发现是，于是获取锁成功。

[Zookeeper 分布式锁 – 图解 – 秒懂](https://cloud.tencent.com/developer/article/2132575)

**Q:  CAP理论。**

1. CAP分别指的是一致性、可用性和分区容错性。该理论认为一个分布式系统是不可能同时满足这三种特性的，只能满足其中两种。
2. 先说P这块，如果在集群中，对某个节点产生通信问题，可能是由于硬件故障、网络故障或软件故障引起的。这时候我们就说集群产生了分区。如果P不满足，意味着只要集群产生了分区，整个集群就死掉，这是不合理的，所以一般而言P是必须满足的。
3. 那么剩下的就在C和A这两者选其一了，对应的系统称作CP系统和AP系统，比如ZooKeeper就是典型的CP系统。
4. C和A的选择要看具体的业务场景，如果对一致性的要求高，例如数据分片，分布式事务等，数据片存储在不同的节点，这时就选CP系统；否则，如果对可用性要求高，系统不能时不时卡死的，就选AP系统。

[一文看懂｜分布式系统之CAP理论](https://cloud.tencent.com/developer/article/1860632)

**Q: BASE理论。**

1. base理论面向大型高可用、可扩展的分布式系统。它允许不做到强一致性，而是根据具体的业务特点 ，采用适当的方式，达成最终一致性。
2. BA是指基本可用（Basically Available），比如一个请求，正常响应要求500ms，但偶尔来个2s，也认为它是可用的；另一方面，比如提交一个购物订单，正常情况下是可以提交的，但在促销高峰时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级的页面。
3. S是指软状态（Soft-state），指的是集群内允许节点之间的数据同步存在延时，即暂时存在数据不一致性，并且认为这种不一致性不会影响系统的整体可用性。
4. E指最终一致性（Eventually Consistent）。在经过一段时间的数据同步后，集群内各节点的数据能达到一致性。实现方式可以有：1）读取时检查，检查到不一致时就修复；2）写入时检查；3）最常用的，定时检查、修复。
5. 对了，银行转账还是要求达到强一致性。

[分布式必备理论基础：CAP和BASE](https://cloud.tencent.com/developer/article/1882578)

**Q: CAP和ACID的一致性有什么区别？**

1. CAP的一致性是指各个节点的数据保持一致；
2. ACID的一致性包含两方面：
	1. 逻辑一致性：比如**单价*数量=金额**，这三个字段的逻辑要保持一致性；
	1. 约束一致性：比如非空字段永远都不为空。

**Q: 什么是分布式事务？**

如果一个业务场景涉及多个服务节点的数据库更新，就需要使用分布式事务保证各个服务形成一个整体性的事务。

分布式事务需要借助一些协调机制来确保各个节点的本地事务能够正确地执行，并且在整个事务完成后，能够保证数据的一致性和可靠性。

常见的协调机制有两阶段、三阶段提交协议，TCC等。

**Q: 分布式事务 2PC，3PC的原理是啥？**

二阶段、三阶段提交协议是从XA协议衍生出来的。XA协议定义了事务管理器和本地资源管理器这两个概念，事务管理器作为一个全局调度者，负责对各个本地资源管理器统一号令，执行提交或回滚操作。

二阶段协议的意思是分成两个阶段，第一准备阶段，通知各个本地事务执行好自身的业务逻辑，但不提交本地事务；第二才是提交阶段。

二阶段有缺点，1是可能由于网络原因，部分节点没有收到提交指令，最后导致数据不一致；2是所有的参与者节点都是事务阻塞的，如果某个节点响应超时了，其余参与者都会被动占用资源不能释放；3是严重依赖协调者，一旦协调者发生故障则也会导致整个集群处于阻塞状态。

三阶段所做的一个改进是在二阶段之前增加了一个阶段，叫“是否可以提交”阶段。参与者收到这个指令后，不做任何事情，只需快速回复协调者。这个预判动作可以快速检查是否有故障的节点，增加整个事务成功的概率，但还是不能彻底避免二阶段存在的问题。

[面试被问分布式事务...](https://cloud.tencent.com/developer/article/1597269	)

**Q: 分布式事务TCC的原理是啥？**

TCC是try，confirm，cancel的简写，每个服务节点都需要实现这三个接口，并且保证逻辑幂等。

举一个常见的订单-库存例子：客户下达订单，库存扣减商品数量，并增加客户积分，其中订单、库存和积分属于三个服务，部署在三个节点里，都有自己的数据库。

回到TCC，在try阶段做的是预备操作。客户下达订单，那么就在订单服务里，将订单状态更新为”创建中“；在库存服务里，将库存数量扣减20，同时用一个”冻结“字段暂存这个20；在积分服务里用一个字段”待加积分“暂存增加的积分；

接着，假如在try阶段，所有的服务都正常完成，那么就进入confirm阶段；如果存在失败的服务，就进入cancel阶段。

在confirm阶段里，各服务节点执行真正的业务更新操作。比如订单服务，将订单状态更新为”已提交“；库存服务，将冻结字段清零；积分服务，将待加积分加到客户积分里，同时待加积分自身清0。如此，提交订单业务顺利完成，相关服务节点的数据保持了一致性。

如果进入cancel阶段，各服务节点就执行取消操作。比如订单服务，将订单状态更新为”提交失败“；库存服务，将库存数量加回冻结的20，同时清零冻结数量；积分服务则直接清零待加积分。

在上述过程中，TCC事务框架会记录一些活动日志。虽然说只要代码没有bug，try阶段正常跑完，confirm和cancel一般都能成功，但假如就是发生失败了，比如某个服务宕机重启之类的，事务框架就会根据活动状态日志重新调用confirm或cancel，直到成功为止。如果发生极端情况，重试N次就是不成功，这时就需要通知人工介入了。

[终于有人把“TCC分布式事务”实现原理讲明白了！](https://www.cnblogs.com/jajian/p/10014145.html)。这篇文章还介绍了可靠消息服务，较为复杂。

Q: 云原生是啥意思？

四要素

[ref](https://juejin.cn/post/6844904197859590151)

# 缓存

Q: 为什么要使用缓存？

使用缓存是为了两个目的：1）实现高性能；2）支撑高并发。

在实现高性能方面，对于一些需要复杂操作耗时得到的结果，且确定后面不怎么变化，但是有很多读请求，那么将结果存入缓存中，后面直接读缓存，可以提高性能。

在支撑高并发方面，如果只使用数据库，瞬间大量的请求会导致大量的IO操作，数据库会死掉；而缓存是走内存的，天然支持高并发。

Q: Redis是什么？

Redis是用C语言写的，基于内存的高性能NoSql数据库，一般用于架设在Java程序和数据库之间用作缓存层。

此外，还可以利用它的数据类型实现一些简单功能，比如用户在线状态、排行版、session缓存等。

它也提供一些支持高可用的机制，比如持久化，主从部署等。

Q: 使用缓存可能会产生什么问题？

可能会产生：

1. 缓存与数据库双写不一致；
2. 缓存集群内各节点的数据不一致；
3. 击穿、穿透、雪崩；
4. 缓存并发竞争。

Q: 如何解决缓存与数据库双写不一致的问题？

首先，确定是否需要严格要求缓存和数据库时刻一致。

如果是，那么就得将读、写请求串行化。串行化可以保证绝对一致，代价是牺牲吞吐量。

如果允许存在偶尔、暂时的不一致，那么采用Cache Aside Pattern：

1. 读的时候，先读缓存，如果缓存没有，再读库，更新缓存并返回响应；
2. 写的时候，先删缓存，再更新库。如果更新库失败，那么顶多是写入失败，不会出现不一致的情况。

Q: 缓存击穿和穿透的区别是什么？

共同点：都是大量请求访问缓存中一个不存在的key，进而都打到数据库的情况。

不同点：

1. 击穿是自然原因引起的，可以是key过期，或者key没有提前预热，或者缓存系统宕机；
2. 穿透是恶意原因引起的，攻击者故意发起大量请求访问一个“事实上不存在的key”，从而达到拖垮系统的目的。

Q: 如何防止击穿、穿透、雪崩？

**共同的保底措施：**

1. Redis集群化部署，增加高可用性；
2. 建立监控和自动化机制，当出现严重问题时能及时发现，并触发熔断、限流、降级。

**针对击穿：**

1. 少量、特别热点的key，设置永不过期，或者（在秒杀等特殊活动开始前）预热；
2. 其他“可能成为热点”的key，第一个请求发现该key不存在时，立刻设置互斥锁，构建完该key缓存后再释放锁，后面被阻塞的请求再访问这个key。（关键要识别到这个key，才能对它应用这个策略）

**针对穿透：**

1. IP监控，发现流量异常的，限流，并且定期分析日志，确定异常的IP加黑名单；
2. 对请求加一些必要的非法参数校验，以便过滤；
3. 如果是瞬间大量请求，且同一个key，或者少数几个key，可以往Redis写一个“not data”值，并设置短暂的过期时间；（可问题是这个key很难在一瞬间识别并予以处理）
4. 使用布隆过滤器（有小概率误判可能）。

**针对雪崩：**

雪崩是指大量的热点key同时失效，大量请求打到数据库的情况。

1. 不同的key尽量设置不同的过期时间，需要开发一个统一的针对key，权值，当前时间等参数，生成过期时间的策略。

Q: Redis的淘汰策略？

当新数据写入，Redis的内存不够用了，就会触发淘汰机制，删除掉一些key以便释放内存。

淘汰策略有8种，可分为4大类：

1. LRU：最近最少使用
2. LFU：最少使用频率
3. Random：随机淘汰
4. ttl: 距离过期时间越近的越先淘汰

前3类都区分了“设置过期时间key”和“所有key”的情况，共6种情况；第4类只针对设置了过期时间的；最后还有一种是永远不淘汰，内存不足时写入新数据会报错。

Q: Redis的过期删除策略。

除了在内存满时触发淘汰策略外，还有其它时点也会触发过期key的删除，不同时点分别对应不同的过期删除策略：

1. 定时删除：添加key的同时给key设置一个定时器，当过期时间到了的时候就立即删除过期key。（每个key都自带一个定时器？）
2. 定期删除：在Redis内部跑一个全局的心跳器，时间周期（默认每秒10次，通过配置文件hz参数[1~500]控制）到了，就随机筛选20个过期key删除；
3. 惰性删除：访问key的时候才检查这个key是否过期，过期了就删除。

定时删除对内存友好，对CPU不友好，惰性删除则刚好相反，定期删除则是两者的折中。

Redis采用的策略是“惰性删除+定期删除”的组合。

Q: 什么是多级缓存？

1. 物理位置离用户近的，放置**绝对静态文件**（css，js）：

	1. 浏览器缓存
	2. CDN缓存

2. 物理位置离服务器近的，放置**部分静态文件**（比如商品详情页，采用“页面静态化”技术，提前生成好的html）：

  1. 反向代理

3. 在Java程序和DB之间的，缓存**动态数据**：

	1. Redis（Session缓存）
  2. MQ（平衡生产者 - 消费者）
  3. ThreadCache（缓存的生命周期只在一个request内）

Q: 如何提高缓存命中率？

TODO

# 团队管理

Q: 团队管理的目标是什么？

假设有4类“组织”：

1. 一个人
2. 一群乌合之众
3. 一群方向一致的人
4. 一群方向一致、且条件充足的人

这4类“组织”的力量对比，从大到小排序为：4 > 3 > 1 > 2.

因此团队管理的目标和对应方法，就是：

1. 促进团队成员发力；

	1. 激励：让成员认可工作的意义和价值，充分激发他们的潜力。例如晋升、加薪或福利；
	2. 文化：增强成员的团结和归宿感，安心专注发展。比如定期举行的技术分享、团建、庆功宴；
	3. 提能：提高成员自身的知识技能，比如提供培训发展机会；
	4. 性格分析：把最合适的性格放在最合适的位置上。
2. 确保团队成员往一致的方向发力。

	1. 制定目标和计划，拆解成可操作的任务，设定时间表和里程碑；
	2. 定期沟通，听取反馈和建议，及时解决问题，确保发力方向正确；
3. 资源和风险管理

	1. 资源管理，包括时间、人员和预算；
	2. 风险管理，包括评估、制定计划减少风险，同时确保成员知晓风险以及如何应对。

Q: 技术leader如何带领开发？

技术leader的职责是包含**技术管理**和**团队管理**两块。

技术管理：

1. 掌握团队关注的业务，使用的技术栈；
2. 主导设计，解决问题，提供指导，把控质量；
3. 跨部门协作时，作为对接人，和对方确定技术对接方案，并和上级、PM同步我们这边需要配合做的事情；
4. 定期分析客户提单和运维慢日志，结合对系统的理解，找出两类问题：

	1. 业务流程存在可优化的点，和产品讨论解决方案；
	2. 非功能问题。和擅长问题涉及点的开发沟通，对齐解决方案后，建立项目任务，由PM安排时间处理。

团队管理：

1. 建立一个意识，自己是服务者和协调者；
2. 了解团队成员各自的擅长领域和性格，做好分工；
4. 常沟通（正式或非正式）：了解他们的意见，需求和困难，解决问题或提供帮助和支持；
4. 和PM保持密切配合：每个迭代，制定并对齐迭代目标、资源分配和时间表，跟踪进度，迭代末尾评估成果和反思。

Q: MBTI性格分析

**MBTI的四个维度 **

外向（**E**xtrovert）vs. 内向（**I**ntrovert) 

具体（**S**ensing）vs. 直觉（i**N**tuition） 

理性（**T**hinking）vs. 感性（**F**eeling） 

计划（**J**udging）vs. 灵活（**P**erceiving)

**维度一：能量获取方式**

当你成为众目睽睽的焦点时，你感到很享受，还是尴尬不适？

**维度二：信息获取方式**

你在吵架的时候，是喜欢抓住具体的细节攻击，还是吵一些抽象的情感？

你是否会经常思考远离实际的抽象问题？比如三体、宇宙、黑洞、人类起源等。

**维度三：决策方式**

当你做决定的时候，更多的是通过思考，还是感觉？

**维度四：行事方式**

你在做一件事情之前，更倾向于提前计划好，还是走一步看一步？

准时，还是丢三落四？

**组合例子**

如果I，N碰到一起，也就是从内心获取能量的，同时靠直觉获取信息的，那么他们就会有一个自我的小世界，也很喜欢研究，整天自己跟自己聊天。所以有些人就很聪明。

T，J组合，做事比较严格，根据成本收益，不太会被情感影响决策。自我要求比较严格，也比较冷酷。

P，J两人在一起可能比较适合，J做计划，P就跟着J走，不容易吵架。

N，S两人可能很难聊到一块去。