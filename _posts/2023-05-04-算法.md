---
layout: post
title: "算法"
mathjax: true
---

Q: 经验提炼

1. 得出一个结果，是否可以剔除一个范围的结果？
2. 动态规划：大问题分解若干小问题，解决小问题，合并解决大问题；
3. 数位提取和翻转；
4. 双指针：一个指针只往一个方向移动；

# 字符串处理

Q: KMP

输入：主字符串，模式字符串

输出：模式字符串在原字符串的位置，或-1

特点：在搜索的过程中无需回退主字符串的索引位置，遍历的时间复杂度为O(n)，n是主字符串的长度。

实现：

**第一步：求出子串的next[]**

```java
public static void main(String[] args) {
		String patternStr = "abaabcac";
		int[] nextArr = getNext(patternStr);
		for(int i : nextArr) {
			System.out.print(i + ", ");
		}
	}
```

输出：0, 0, 0, 1, 0, 2, 0, 1, 

含义：

1. 前两位的值为0；
2. 从第 i 位（i >=2, 按下标以0开始来说，后同）开始，值等于k，满足在i之前的长度为k的子串，等于从0开始，长度为k的子串；

   1. 比如，第3位的值为1，表明第2位（a）等于第0位（a）
   2. 再比如，第5位的值为2，表明第3,4位（ab）等于第0,1位（ab）

3. 如果第i位的字符，等于第next[i]位的字符，则第i位的值，等于第next[i]位的值。

   1. 这是因为在和主串比较时，当第i位的字符不等时，第next[i]位的字符肯定也不等，所以就没必要比较第next[i]
   位了，直接比较这个字符最开始出现的地方；
   2. 比如第4位是b，按理说next[4]应该等于1，但str[1] == str[4]，所以next[4] = next[1] = 0.

getNext()方法实现如下：

```java
private static int[] getNext(String patternStr) {
		int[] nextArr = new int[patternStr.length()];
		char[] patternArr = patternStr.toCharArray();
		int j = 0; 
		for(int i = 1; i < patternArr.length-1;) {
			if(patternArr[i] == patternArr[j]) {
				i++;
				j++;
				nextArr[i] = j;
				if(patternArr[i] == patternArr[j]) {
					nextArr[i] = nextArr[j];
				}
			}else if(j > 0) {
				j = nextArr[j];
			}else {
				i++;
				nextArr[i] = j;
			}
		}
		return nextArr;
	}
```

**第二步，查找首次出现的位置**

```java
public static void main(String[] args) {
		String str = "acabaabaabcacaabc";
		String patternStr = "abaabcac";
		System.out.println(search(str, patternStr));
	}
```

输出：5

分析：当子串移到主串的第2位时，发现主串的第7位，子串的第5位不相等。但next[5]==2，意味着主串的前2位（第5,6位）和子串的第0,1位是相等的，所以主串的第7位直接和子串的第2位继续比较就行，发现也不相等，所以主串的索引只好前进1位，子串的索引归0.

```text
acabaabaabcacaabc
  abaabcac
```

当子串移到主串的第5位时，发现匹配了，最后拿主串的索引减去子串的长度返回结果。

```java
private static int search(String str, String patternStr) {
		int[] nextArr = getNext(patternStr);
		for(int i : nextArr) {
			System.out.print(i + ", ");
		}
		System.out.println();
		
		char[] strArr = str.toCharArray();
		char[] patternArr = patternStr.toCharArray();
		int i = 0, j = 0;
		int result = -1;
		while(true) {
			if(strArr[i] == patternArr[j]) {
				i++;
				j++;
				if(j == patternArr.length) {
					result = i - patternArr.length;
					break;
				}
				if(i == strArr.length) {
					break;
				}
				
			}else if(j > 0){
				j = nextArr[j];
			}else {
				i++;
				if(i == strArr.length) {
					break;
				}
			}
		}
		return result;
	}
```

Q: RPN

定义两个栈：S1，S2，逐个字符遍历标准表达式：

1. 遇到左括号，压入S1
2. 遇到数字，压入S2
3. 遇到运算符：

   1. 如果该运算符优先级小于s1栈顶操作符优先级，则将栈顶运算符取出压入s2栈，循环此步骤直到不满足上述条件为止；
   2. 最后将该运算符压入s1
   
4. 遇到右括号，则将S1中的内容逐个pop出，push进S2，直到S1中遇到左括号为止（注意左括号要从S1中pop出，但不要posh进S2）

```java
public class RPN {
	private static List<String> opLst = Arrays.asList("+", "-", "*", "/");
	private static Map<String, Integer> priorityMap = new HashMap<>();
	static {
		priorityMap.put("+", 10);
		priorityMap.put("-", 10);
		priorityMap.put("*", 20);
		priorityMap.put("/", 20);
	}
	
	public static void main(String[] args) {
		String expression = "( ( 3 + 4 ) * 5 ) - 6 * 2 * ( 1 + 7 )";
		Stack<String> s1 = new Stack<>();
		Stack<String> s2 = new Stack<>();
		
		String[] expArr = expression.split(" ");
		for(String exp : expArr) {
			if("(".equals(exp)) {
				s1.push(exp);
			}else if(isInteger(exp)) {
				s2.push(exp);
			}else if(opLst.contains(exp)) {
				// 如果该运算符优先级小于s1栈顶操作符优先级，则将栈顶运算符取出压入s2栈
				// 循环此步骤直到不满足上述条件为止
				// 最后将该运算符压入s1
				while(!s1.isEmpty()) {
					String peek = s1.peek();
					if(!opLst.contains(peek)) {
						break;
					}
					if(priorityMap.get(exp) <= priorityMap.get(peek)) {
						s2.push(s1.pop());
					}else {
						break;
					}
				}
				s1.push(exp);
			}else if(")".equals(exp)) {
				while(!s1.isEmpty()) {
					String _exp = s1.pop();
					if(_exp.equals("(")) {
						break;
					}
					s2.push(_exp);
				}
			}
		}
		
		while(!s1.isEmpty()) {
			s2.push(s1.pop());
		}
		
		for(String exp: s2) {
			System.out.print(exp + ", ");
		}
	}
	
	public static boolean isInteger(String str) {    
		Pattern pattern = Pattern.compile("^-?[0-9]+(\\.[0-9]+)?$");    
		return pattern.matcher(str).matches();    
	}
}
```

输入：( ( 3 + 4 ) * 5 ) - 6 * 2 * ( 1 + 7 )

输出：3, 4, +, 5, *, 6, 2, *, 1, 7, +, *, -, 

# 排序

Q: 快排

输入：int[] arr = new int[] {1,1,2,0,9,3,12,7,8,3,4,65,22};

输出：0, 1, 1, 2, 3, 3, 4, 7, 8, 9, 12, 22, 65, 

要点：分治法。

1. 定义begin，end，分别指处理范围的首尾指针；
2. 执行int position = partition(begin, end)
3. 整个arr分成[arr, position-1], [position+1, end]两部分，每部分重新执行第1步，直到begin <= end

```java
private static void qSort_1(int[] arr, int begin, int end) {
		if(begin >= end) {
			return;
		}
		
		int position = partition(arr, begin, end);
		qSort_1(arr, begin, position-1);
		qSort_1(arr, position+1, end);
	}
```

partition的处理是关键：

1. 定义pivot中枢元素，一般取arr[end]；
2. 定义替换指针(secondIndex)，游标指针(thirdIndex)，初始值都可以是begin；
3. thirdIndex不断右移，将每一个元素和pivot比较，若是小于等于，则替换secondIndex和thirdIndex的元素，并且secondIndex自增1；
4. 直到thirdIndex == end-1为止，此时替换secondIndex和end的元素，并返回secondIndex，作为外面的position。

```java
private static int partition(int[] arr, int begin, int end) {
		int pivot = arr[end]; // 枢纽元素
		int secondIndex = begin; // 替换指针
		int thirdIndex = begin; // 游标指针
		
		while(thirdIndex < end) {
			// 将比pivot小的元素都挪到最左边去
			if(arr[thirdIndex] <= pivot) {
				if(secondIndex != thirdIndex) {
					int temp = arr[secondIndex];
					arr[secondIndex] = arr[thirdIndex]; 
					arr[thirdIndex] = temp;
				}
				// 如果是和pivot相等的，后面比它小的也不用替换到这个位置了。
				secondIndex++;
			}
			thirdIndex++;
		}
		
		// pivot和secondIndex中的元素互换位置
		arr[end] = arr[secondIndex];
		arr[secondIndex] = pivot;
		
		return secondIndex;
	}
```

最后，递归对于调试而言是个噩梦，由于递归的本质是压栈，所以改为非递归版本如下：

```java
private static void qSort_2(int[] arr, int begin, int end) {
		if(begin >= end) {
			return;
		}
		
		Stack<Integer> stack = new Stack<Integer>();
		stack.push(begin);
		stack.push(end);
		while(!stack.isEmpty()) {
			end = stack.pop();
			begin = stack.pop();
			if(begin >= end) {
				continue;
			}
			loop++;
			int position = partition(arr, begin, end);
			stack.push(begin);
			stack.push(position-1);
			stack.push(position+1);
			stack.push(end);
		}
	}
```

主程序：

```java
public static void main(String[] args) {
		int[] arr = new int[] {1,1,2,0,9,3,12,7,8,3,4,65,22};
		qSort_2(arr, 0, arr.length-1);
		for(int i : arr) {
			System.out.print(i + ", ");
		}
	}
```

# 数位处理

Q: 如何将123转为321？

```java
int x = 123;
int y = 0;
while(x > 0){
  int remainder = x % 10;
  x /= 10;
  y = y * 10 + remainder;
}
// now y == 321
```

Q: 如何从1234取出高2位“12”？

1234/100即可得到。

换个思路，也可以除以2次10得到。这里可以玩出花样，比如判断是否“回文数”时，可以一边取高位数，一边翻转低位数（这里也包含“双指针”思想）。

# 双指针

变体：滑动窗口